/*++
  This file contains 'Framework Code' and is licensed as such
  under the terms of your license agreement with Intel or your
  vendor.  This file may not be modified, except as allowed by
  additional terms of your license agreement.
--*/
/*++

Copyright (c) 2014 - 2019 Intel Corporation. All rights reserved
This source code and any documentation accompanying it ("Material") is furnished
under license and may only be used or copied in accordance with the terms of that
license.  No license, express or implied, by estoppel or otherwise, to any
intellectual property rights is granted to you by disclosure or delivery of these
Materials.  The Materials are subject to change without notice and should not be
construed as a commitment by Intel Corporation to market, license, sell or support
any product or technology.  Unless otherwise provided for in the license under which
this Material is provided, the Material is provided AS IS, with no warranties of
any kind, express or implied, including without limitation the implied warranties
of fitness, merchantability, or non-infringement.  Except as expressly permitted by
the license for the Material, neither Intel Corporation nor its suppliers assumes
any responsibility for any errors or inaccuracies that may appear herein.  Except
as expressly permitted by the license for the Material, no part of the Material
may be reproduced, stored in a retrieval system, transmitted in any form, or
distributed by any means without the express written consent of Intel Corporation.


Module Name:

  CrystalRidge.asi

Abstract:

  Crystal Ridge NVDIMM ACPI implementation

--*/

#include "CrystalRidgeDebug.asi"

#define DCPMM_DSM_SWSMI 0xFC

#define DSM_ROOT_QUERY_ARS_CAPABILITES         1
#define DSM_ROOT_START_ARS                     2
#define DSM_ROOT_QUERY_ARS_STATUS              3
#define DSM_ROOT_CLEAR_UNCORRECTABLE_ERROR     4
#define DSM_ROOT_TRANSLATE_SPA                 5
#define DSM_ROOT_RESERVED                      6
#define DSM_ROOT_ARS_ERROR_INJECT              7
#define DSM_ROOT_ARS_ERROR_INJECT_CLEAR        8
#define DSM_ROOT_ARS_ERROR_INJECT_STATUS_QUERY 9
#define DSM_ROOT_LAST                          DSM_ROOT_ARS_ERROR_INJECT_STATUS_QUERY
#define DSM_ROOT_STOP_ARS_AND_UPDATE_STATUS    0xFFFFFFFD
#define DSM_ROOT_CHECK_LONGOP_STATE            0xFFFFFFFF

#define DSM_ROOT_DEVICE_ACPI_HANDLE   0xFFFFFFFF

#define DSM_LEAF_UUID "4309AC30-0D11-11E4-9191-0800200C9A66"
#define DSM_1_4_REV   1
#define DSM_1_8_REV   2

#define ACPI_STS_SUCCESS            0x00
#define ACPI_STS_NOT_IMPLEMENTED    0x01
#define ACPI_STS_INVALID_PARAMS     0x02  // Invalid input parameters
#define ACPI_STS_HW_ERROR           0x03
#define ACPI_STS_RETRY_SUGGESTED    0x04  // Temporary cannot execute
#define ACPI_STS_UNKNOWN_ERROR      0x05
#define ACPI_STS_METHOD_SPECIFIC    0x06  // Extended status defines method specific error

#define DSM_STS_SUCCESS             0x00
#define DSM_STS_NOT_SUPPORTED       0x01  // Function not supported
#define DSM_STS_NO_MEM_DEVICE       0x02
#define DSM_STS_INVALID_PARAMS      0x03
#define DSM_STS_HW_ERROR            0x04
#define DSM_STS_RETRY_SUGGESTED     0x05  // Temporary cannot execute
#define DSM_STS_UNKNOWN_FAIL        0x06
#define DSM_STS_VEN_SPECIFIC_ERROR  0x07  // Extended status defines function specific error
#define DSM_STS_OUTOFRESOURCES      0x08
#define DSM_STS_NOTREADY            0x09
#define DSM_STS_INVSECSTATE         0x0A  // Invalid security state
#define DSM_STS_INVPASSPHRASE       0x0B  // Invalid passphrase supplied

//
// DSM extened status codes for Overwrite NVDIMM function.
//
#define DSM_STS_EXT_OVERWRITE_NOTALLOWED    0x00010007
#define DSM_STS_EXT_OVERWRITE_INPROGRESS    0x00010007
#define DSM_STS_EXT_OVERWRITE_OUTOFSEQUENCE 0x00020007

#define DSM_FN_GET_SMART_INFO                    1
#define DSM_FN_GET_SMART_THRESHOLD               2
#define DSM_FN_GET_BLOCK_FLAGS                   3
#define DSM_FN_GET_LABEL_SIZE                    4
#define DSM_FN_GET_LABEL_DATA                    5
#define DSM_FN_SET_LABEL_DATA                    6
#define DSM_FN_GET_VENDOR_LOG_SIZE               7
#define DSM_FN_GET_VENDOR_LOG                    8
#define DSM_FN_VENDOR_COMMAND                    9
#define DSM_FN_ENABLE_LATCH_SYSTEM_SHUTDOWN_STATUS 10
#define DSM_1_4_LASTFN                          DSM_FN_ENABLE_LATCH_SYSTEM_SHUTDOWN_STATUS
#define DSM_FN_GET_SUPP_MODES                   11
#define DSM_FN_GET_FWUPDATE_INFO                12
#define DSM_FN_START_FWUPDATE                   13
#define DSM_FN_SEND_FWUPDATE_DATA               14
#define DSM_FN_FINISH_FWUPDATE                  15
#define DSM_FN_QUERY_FWUPDATE                   16
#define DSM_FN_SET_SMART_THRESHOLD              17
#define DSM_FN_INJECT_ERROR                     18
#define DSM_FN_GET_SECURITY_STATE               19
#define DSM_FN_SET_PASSPHRASE                   20
#define DSM_FN_DISABLE_PASSPHRASE               21
#define DSM_FN_UNLOCK_UNIT                      22
#define DSM_FN_FREEZE_LOCK                      23
#define DSM_FN_SECURE_ERASE_NVDIMM_USER         24
#define DSM_FN_OVERWRITE_NVDIMM                 25
#define DSM_FN_QUERY_OVERVRITE_STATUS           26
#define DSM_FN_SET_MASTERPASSPHRASE             27
#define DSM_FN_SECURE_ERASE_NVDIMM_MASTER       28
#define DSM_1_8_LASTFN                          DSM_FN_SECURE_ERASE_NVDIMM_MASTER
#define DSM_FN_CHECK_LONGOP_STATE       0xFFFFFFFF

// FIS commands of interest
#define FIS_CMD_IDENTIFY_DIMM               0x0001
#define FIS_CMD_GET_SECURITY_STATE          0x0002
#define FIS_CMD_SET_SECURITY_MAJOR            0x03  // Major code of set-security cmds
#define FIS_CMD_OVERWRITE_DIMM              0x0103
#define FIS_CMD_SET_MASTERPASSPHRASE        0xF003
#define FIS_CMD_SET_PASSPHRASE              0xF103
#define FIS_CMD_DISABLE_PASSPHRASE          0xF203
#define FIS_CMD_UNLOCK_UNIT                 0xF303
#define FIS_CMD_SECURE_ERASE_UNIT           0xF503
#define FIS_CMD_FREEZE_LOCK                 0xF603
#define FIS_CMD_GET_ALARM_THRESHOLD         0x0104
#define FIS_CMD_SET_ALARM_THRESHOLD         0x0105
#define FIS_CMD_SET_ADDRESS_RANGE_SCRUB     0x0405
#define FIS_CMD_GET_PLATFORM_CONFIG         0x0106
#define FIS_CMD_SET_PLATFORM_CONFIG         0x0107
#define FIS_CMD_SET_LATCH_SYSTEM_SHUTDOWN_STATUS 0x0907
#define FIS_CMD_SMART_AND_HEALTH_INFO       0x0008
#define FIS_CMD_GET_FIRMWARE_DEBUG          0x0208
#define FIS_CMD_GET_LONG_OPERATION          0x0408
#define FIS_CMD_UPDATE_FIRMWARE             0x0009
#define FIS_CMD_INJECT_POISON               0x010A
#define FIS_CMD_INJECT_MEDIA_TEMP_ERROR     0x020A
#define FIS_CMD_INJECT_SW_TRIGGER           0x030A
#define FIS_CMD_EMULATED_MAJOR                0xFD
#define FIS_CMD_GET_LP_MB_INFO              0x00FD
#define FIS_CMD_WRITE_LP_INPUT_MB           0x01FD
#define FIS_CMD_READ_LP_OUTPUT_MB           0x02FD
#define FIS_CMD_GET_BOOT_STATUS             0x03FD
#define FIS_CMD_IMF_FORMAT_CMD              0X04FD
#define FIS_CMD_EXTENDED_VEN_SPEC           0X05FD

#define FIS_STS_SUCCESS                     0x00
#define FIS_STS_INVALID_PARAM               0x01
#define FIS_STS_DATA_XFER_ERR               0x02
#define FIS_STS_INTERNAL_ERR                0x03
#define FIS_STS_UNSUPPORTED_CMD             0x04
#define FIS_STS_DEVICE_BUSY                 0x05
#define FIS_STS_INCORRECT_NONCE             0x06
#define FIS_STS_SECURITY_CHK_FAIL           0x07
#define FIS_STS_INVALID_SEC_STATE           0x08
#define FIS_STS_SYS_TIME_NOT_SET            0x09
#define FIS_STS_DATA_NOT_SET                0x0A
#define FIS_STS_ABORTED                     0x0B
#define FIS_STS_NO_NEW_FW                   0x0C
#define FIS_STS_REVISION_FAIL               0x0D
#define FIS_STS_INJECT_NOT_ENABLED          0x0E
#define FIS_STS_CONFIG_LOCKED               0x0F
#define FIS_STS_INVALID_ALIGNMENT           0x10
#define FIS_STS_INCOMPATIBLE_DIMM           0x11
#define FIS_STS_TIMEOUT                     0x12
#define FIS_STS_INVALID_COMMAND_VERSION     0x13
#define FIS_STS_MEDIA_DISABLED              0x14
#define FIS_STS_FW_UPDATE_ALREADY_OCCURRED  0x15
#define FIS_STS_NO_RESOURCES_AVAILABLE      0x16

#define CLDP_RETURN         Zero
#define CLDP_PROCESS        1

#define ICTL_NODDRTSMI      0x02
#define ICTL_LSX_ASL        0x04

#define NAMESPACE_DATA_CHUNK_MAX_SIZE        65152
#define NAMESPACE_DATA_CHUNK_MAX_SIZE_PAD    65408 // need extra 2x128B for unaligned max-chunk-size requests
#define NAMESPACE_DATA_WRITE_CHUNK_SIZE      64
#define NAMESPACE_DATA_WRITE_CHUNK_SIZE_BITS 512
#define NAMESPACE_DATA_WRITE_CHUNK_SIZE_MASK 63
#define MAX_DUMP_SIZE                        64
#define NAMESPACE_DATA_READ_CHUNK_SIZE       128
#define NAMESPACE_DATA_READ_CHUNK_SIZE_MASK  127

#define STRINGIFY(X) #X

Name (TFSM, 10000000)
  //
  // Remaps GetNamespaceLabelData and SetNamespaceLabelData error codes to _LSR/_LSW error codes
  //
  Method (ERMP, 1)
  {
    if (LEqual (Arg0, DSM_STS_SUCCESS)) {
      Return (LABEL_STORAGE_SUCCESS)
    }
    if (LEqual (Arg0, DSM_STS_INVALID_PARAMS)) {
      Return (LABEL_STORAGE_INVALID_INPUT)
    }
    if (LEqual (Arg0, DSM_STS_HW_ERROR)) {
      Return (LABEL_STORAGE_HW_FAILURE)
    }
    if (LEqual (Arg0, 0x10000)) { // Operation successfull although DIMM is locked
      Return (0)
    }
    if (LEqual (Arg0, 0x10007)) { // Operation failed because DIMM is locked
      Return (LABEL_STORAGE_LOCKED)
    }
    Return (LABEL_STORAGE_FAILURE)
  }

  //
  // _LSI method implementation
  //
  // Input:
  //   Void.
  // Output:
  //   Package {Status, SizeOfLabelStorageArea, MaxTransferLen}
  //
#define DEFINE_CLSI(_DIMM)                                  \
  Method (CLSI, 0, Serialized)                              \
  {                                                         \
    If (LNotEqual (CENA, 1)) {                              \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " CLSI: No NVDIMM") \
      Return (Package () {LABEL_STORAGE_FAILURE, 0, 0})     \
    }                                                       \
    Store (Package () {}, Local0)                           \
    Store (CRLD (ToUUID (DSM_LEAF_UUID), DSM_1_4_REV, 4, Local0, _ADR), Local1) \
    If (LLess (SizeOf (Local1), 12)) {                      \
      Return (Package () {LABEL_STORAGE_FAILURE, 0, 0})     \
    }                                                       \
    CreateDWordField (Local1, 0, LSTS)                      \
    CreateDWordField (Local1, 4, LSIZ)                      \
    CreateDWordField (LOcal1, 8, LTXL)                      \
    Store (Package () {0, 0, 0}, Local2)                    \
    Store (ERMP (LSTS), Index (Local2, 0))                  \
    Store (ToInteger (LSIZ), Index (Local2, 1))             \
    Store (ToInteger (LTXL), Index (Local2, 2))             \
    Return (Local2)                                         \
  }

  //
  // _LSR method implementation
  //
  // Input:
  //   Arg0 - Offset in Label Storage Area
  //   Arg1 - TransferLen
  // Output
  //   Package {Status, Buffer {LabelData}}
  //
#define DEFINE_CLSR(_DIMM)                                                    \
  Method (CLSR, 2, Serialized)                                                \
  {                                                                           \
    If (LNotEqual (CENA, 1)) {                                                \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " CLSR: No NVDIMM") \
      Return (Package () {LABEL_STORAGE_FAILURE, Buffer () {0}})              \
    }                                                                         \
    If (LEqual (Arg1, 0)) { /* if TransferLen is zero just return success */  \
      Return (Package() {LABEL_STORAGE_SUCCESS, Buffer () {}})                \
    }                                                                         \
    Store (Package () {Buffer (8) {}}, Local0)                                \
    CreateDWordField (DeRefOf (Index (Local0, 0)), 0, CHUO)                   \
    CreateDWordField (DeRefOf (Index (Local0, 0)), 4, CHUS)                   \
    Store (Arg0, CHUO)                                                        \
    Store (Arg1, CHUS)                                                        \
    Store (CRLD (ToUUID (DSM_LEAF_UUID), DSM_1_4_REV, 5, Local0, _ADR), Local1) \
    CreateDWordField (Local1, 0, LSTS)                                        \
    Store (Package() {LABEL_STORAGE_SUCCESS, Buffer () {0}}, Local2)          \
    Store (ERMP(LSTS), Index(Local2, 0))                                      \
    if (LEqual (DeRefOf (Index(Local2, 0)), 0)) {                             \
      Multiply (Subtract (SizeOf (Local1), 4), 8, Local3)                     \
      CreateField (Local1, 32, Local3, CHUD)                                  \
      Store (CHUD, Index(Local2, 1))                                          \
    }                                                                         \
    Return (Local2)                                                           \
  }

  //
  // _LSW method implementation
  //
  // Input:
  //   Arg0 - Offset in Label Storage Area
  //   Arg1 - TransferLen
  //   Arg2 - Buffer with LabelData
  // Output:
  //   Status
#define DEFINE_CLSW(_DIMM)                                                    \
  Method (CLSW, 3, Serialized)                                                \
  {                                                                           \
    If (LNotEqual (CENA, 1)) {                                                \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " CLSW: No NVDIMM") \
      Return (LABEL_STORAGE_FAILURE)                                          \
    }                                                                         \
    If (LEqual (Arg1, 0)) { /* if TransferLen is zero just return success */  \
      Return (LABEL_STORAGE_SUCCESS)                                          \
    }                                                                         \
    Store (SizeOf (Arg2), Local3)                                             \
    If (LEqual (Local3, 0)) {                                                 \
      Return (LABEL_STORAGE_INVALID_INPUT) /* non zero write but empty buffer given */\
    }                                                                         \
    Store (Package () {Buffer (Add (Local3, 8)) {}}, Local0)                  \
    CreateDWordField (DeRefOf (Index (Local0, 0)), 0, CHUO)                   \
    CreateDWordField (DeRefOf (Index (Local0, 0)), 4, CHUS)                   \
    CreateField (DeRefOf (Index (Local0, 0)), 64, Multiply (Local3, 8), CHUD) \
    Store (Arg0, CHUO)                                                        \
    Store (Arg1, CHUS)                                                        \
    Store (Arg2, CHUD)                                                        \
    Store (CRLD (ToUUID (DSM_LEAF_UUID), DSM_1_4_REV, 6, Local0, _ADR), Local1) \
    CreateDWordField (Local1, 0, LSTS)                                        \
    Return (ERMP(LSTS))                                                       \
  }


//
// _NCH method implementation for Crystal Ridge NVDIMM
//
// Input:
//   Void.
// Output:
//   Buffer {Status, Extended Status, Health Data}
//
#define DEFINE_CNCH(_DIMM)                                                    \
  Method (CNCH, 0, Serialized)                                                \
  {                                                                           \
    If (LNotEqual (CENA, 1)) {                                                \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " CNCH: No NVDIMM") \
      Return (Buffer (64) {ACPI_STS_HW_ERROR})                                \
    }                                                                         \
    Store (Buffer (64) {ACPI_STS_SUCCESS}, Local0)                            \
    CreateDWordField (Local0, 0, RSTS)                                        \
    Store (CMBC (FIS_CMD_SMART_AND_HEALTH_INFO, Buffer () {0,0,0,0}, Zero), Local1) \
    Store (CF2A (DerefOf (Index (Local1, 0))), RSTS)                          \
    If (LNotEqual (RSTS, ACPI_STS_SUCCESS)) {                                 \
      Return (Local0)                                                         \
    }                                                                         \
    Store (CF2A (DerefOf (Index (Local1, 1))), RSTS)                          \
    If (LNotEqual (RSTS, ACPI_STS_SUCCESS)) {                                 \
      Return (Local0)                                                         \
    }                                                                         \
    Store (DerefOf (Index (Local1, 2)), Local2)                               \
    /*                                                                        \
     * We have got valid response copied to Local2.                           \
     * First let's check if Health Status is valid.                           \
     */                                                                       \
    If (And (DerefOf (Index (Local2, 0)), 0x01)) {                            \
      /*                                                                      \
       * Health Status is valid, in the response in Local0 set                \
       * payload is valid in Overall Health Status Flags.                     \
       */                                                                     \
      Or (DerefOf (Index (Local0, 4)), 1, Index (Local0, 4))                  \
      If (And (DerefOf (Index (Local2, 8)), 0x01)) {                          \
        /*                                                                    \
         * If Health Status Noncritical is signalled for any reasons just     \
         * set Overall Health Status Flags Bit[0] - maintenance needed.       \
         */                                                                   \
        Or (DerefOf (Index (Local0, 6)), 1, Index (Local0, 6))                \
      }                                                                       \
      If (And (DerefOf (Index (Local2, 8)), 0x02)) {                          \
        /*                                                                    \
         * If Health Status Critical is signalled analyse the reason.         \
         * First check if Health Status Reason is valid.                      \
         */                                                                   \
        If (And (DerefOf (Index (Local2, 0)), 0x80)) {                        \
                                                                              \
          If (And (DerefOf (Index (Local2, 21)), 0x08)) {                     \
            /*                                                                \
             * Critical: percentage remaining equals 0.                       \
             * Set Overall Health Status Flags Bit[10] - write persistency loss imminent\
             * Set Overall Health Status Flags Bit[18] - all data loss imminent\
             */                                                               \
            Or (DerefOf (Index (Local0, 7)), 4, Index (Local0, 7))            \
            Or (DerefOf (Index (Local0, 8)), 4, Index (Local0, 8))            \
          }                                                                   \
          If (And (DerefOf (Index (Local2, 21)), 0x10)) {                     \
            /*                                                                \
             * Critical: die failure (after package sparring if availbale).   \
             * Set Overall Health Status Flags Bit[18] - all data loss imminent\
             */                                                               \
            Or (DerefOf (Index (Local0, 8)), 4, Index (Local0, 8))            \
          }                                                                   \
          if (And (DerefOf (Index (Local2, 21)), 0x20)) {                     \
            /*                                                                \
             * Critical: AIT DRAM state is disabled.                          \
             * Set Overall Health Status Flags Bit[0] - maintenance needed    \
             * Set Overall Health Status Flags Bit[1] - performance degraded  \
             */                                                               \
            Or (DerefOf (Index (Local0, 6)), 3, Index (Local0, 6))            \
          }                                                                   \
          if (And (DerefOf (Index (Local2, 21)), 0x40)) {                     \
            /*                                                                \
             * Critical: CAP self-test fails.                                 \
             * Set Overall Health Status Flags Bit[8] - write persistency loss in event of power loss\
             */                                                               \
            Or (DerefOf (Index (Local0, 7)), 1, Index (Local0, 7))            \
          }                                                                   \
        } Else {                                                              \
                                                                              \
          DEBUG2 (Local6, DEBUG_ERROR, "LEAF", STRINGIFY(_DIMM), " CNCH: Health Status Reason is NOT valid (FW bug?)") \
          Or (DerefOf (Index (Local0, 8)), 4, Index (Local0, 8))              \
        }                                                                     \
      }                                                                       \
      If (And (DerefOf (Index (Local2, 8)), 0x04)) {                          \
        /*                                                                    \
         * Health Status is fatal, for any reason set                         \
         * Overall Health Status Flags Bit[18] - all data loss imminent       \
         */                                                                   \
        Or (DerefOf (Index (Local0, 8)), 4, Index (Local0, 8))                \
      }                                                                       \
    }                                                                         \
    Return (Local0)                                                           \
  }


//
// _NBS method implementation for Crystal Ridge NVDIMM
//
// Input:
//   Void
// Output
//   Buffer {Status, Extended Status, Health Data}
//
#define DEFINE_CNBS(_DIMM)                                                    \
  Method (CNBS, 0, Serialized)                                                \
  {                                                                           \
    If (LNotEqual (CENA, 1)) {                                                \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " CNBS: No NVDIMM") \
      Return (Buffer (64) {ACPI_STS_HW_ERROR})                                \
    }                                                                         \
    Store (Buffer (64) {ACPI_STS_SUCCESS}, Local0)                            \
    CreateDWordField (Local0, 0, RSTS)                                        \
    Store (CMBC (FIS_CMD_SMART_AND_HEALTH_INFO, Buffer () {0,0,0,0}, Zero), Local1) \
    Store (CF2A (DerefOf (Index (Local1, 0))), RSTS)                          \
    If (LNotEqual (RSTS, ACPI_STS_SUCCESS)) {                                 \
      Return (Local0)                                                         \
    }                                                                         \
    Store (CF2A (DerefOf (Index (Local1, 1))), RSTS)                          \
    If (LNotEqual (RSTS, ACPI_STS_SUCCESS)) {                                 \
      Return (Local0)                                                         \
    }                                                                         \
    /* We have got valid response, copy it to Local2 */                       \
    Store (DerefOf (Index (Local1, 2)), Local2)                               \
    If (And (DerefOf (Index (Local2, 0)), 0x20)) {                            \
      /*                                                                      \
       * Latched Dirty Shutdown Count is valid in FIS response, mark it       \
       * valid in the _NBS payload in Local0 and copy its value.              \
       */                                                                     \
      Store (1, Index (Local0, 4))                                            \
      CreateDWordField (Local0, 6, DLC)                                       \
      Mid (Local2, 16, 4, DLC)                                                \
    }                                                                         \
    Return (Local0)                                                           \
  }


  //
  // If leaf PSN != leaf CSN, ORs bitmap from Arg0 with leaf device notification bitmap and returns the result,
  // otherwise returns Arg0
  //
  Method (CALD, 1)
  {
    Store (Arg0, Local0)
    Store (NPSN, Local1)
    if (LNotEqual (NCSN, Local1)) {
      Or (NBM0, ToInteger (DeRefOf (Index (Local0, 0))), Index (Local0, 0))
      Or (NBM1, ToInteger (DeRefOf (Index (Local0, 1))), Index (Local0, 1))
      Store (Local1, NCSN)
    }
    Return (Local0)
  }

  //
  // If root PSN != root CSN, ORs value from Arg0 with root device notification status and returns the result,
  // otherwise returns Arg0
  //
  Method (CARD, 1)
  {
    Store (Arg0, Local3)
    Store (RPSN, Local1)
    if (LNotEqual (RCSN, Local1)) {
      Store(RNST, Local2)
      Or (Local2, Local3, Local3)
      Store (Local1, RCSN)
    }
    Return (Local3)
  }

  //
  // Process leaf notifications pre SWGPE disable
  //
  Method (CLPR, 0)
  {
    Store (Package () {0x00, 0x00}, Local0)

    Return (CALD (Local0))
  }

  //
  // Process root notifications pre SWGPE disable
  //
  Method (CRPR, 0)
  {
    Store (Zero, Local3)

    Return (CARD (Local3))
  }

  //
  // Process leaf notifications pre SWGPE disable
  //
  Method (CLPT, 1)
  {
    Return (CALD (Arg0))
  }

  //
  // Process root notifications post SWGPE disable
  //
  Method (CRPT, 1)
  {
    Return (CARD (Arg0))
  }

  //
  // Crystal Ridge Leaf DSM Preprocessing (CLDP)
  //
  // Validates input. Returns a disposition on subsequent processing to the caller.
  //
  // Input:
  //   Arg0: DIMM string
  //   Arg1: GUID
  //   Arg2: Revision
  //   Arg3: Function Index
  //
  // Output: Package:
  // Index0:
  //   CLDP_RETURN:  No further processing required. Index1 contains data to return to the caller.
  //   CLDP_PROCESS: Continue processing in ASL/SMM.
  // Index1:
  //   Index0 == CLDP_PROCESS: not present
  //   Index0 == CLDP_RETURN:  NVDIMM DSM spec error code or method result
  //
  Method (CLDP, 4, Serialized)
  {
    ToInteger (Arg2, Local1) // Make sure revision in Arg2 is integer
    ToInteger (Arg3, Local2) // Make sure function in Arg3 is integer

    If (LEqual (Local2, 0)) {
      //
      // Return bitmap of supported functions. The bitmap depends on UUID and revision used.
      // For invalid UUID no funcions are supported. For DSM 1.4 return functions 0..10,
      // for DSM 1.6 return 0..18. For other revisions no functions are supported.
      //
      If (LNotEqual (Arg1, ToUUID (DSM_LEAF_UUID))) {

        Return (Package () {CLDP_RETURN, Buffer () {0x00}})
      }
      If (LEqual (Local1, DSM_1_4_REV)) {

        Return (Package () {CLDP_RETURN, Buffer() {0xFF, 0x07}})

      } ElseIf (LEqual (Local1, DSM_1_8_REV)) {

        Return (Package () {CLDP_RETURN, Buffer() {0xFF, 0xFF, 0xFF, 0x1F}})

      } Else {

        Return (Package () {CLDP_RETURN, Buffer() {0x00}})
      }
    }
    If (LNotEqual (Arg1, ToUUID (DSM_LEAF_UUID))) { // Verify UUID of the API

      Return (Package () {CLDP_RETURN, Buffer() {DSM_STS_INVALID_PARAMS, 0, 0, 0}})
    }
    If (LAnd (LNotEqual (Local1, DSM_1_4_REV),
              LNotEqual (Local1, DSM_1_8_REV))) {  // Make sure correct revision

      Return (Package () {CLDP_RETURN, Buffer() {DSM_STS_INVALID_PARAMS, 0, 0, 0}})
    }
    //
    // Only process the supported function indexes
    //
    If (LOr (LAnd (LEqual (Local1, DSM_1_4_REV), LGreater (Local2, DSM_1_4_LASTFN)),
             LAnd (LEqual (Local1, DSM_1_8_REV), LGreater (Local2, DSM_1_8_LASTFN)))) {

      Return (Package () {CLDP_RETURN, Buffer() {DSM_STS_NOT_SUPPORTED, 0, 0, 0}})
    }
    Return (Package () {CLDP_PROCESS})
  }

  //
  // Crystal Ridge Leaf DSM Core (CLDC)
  //
  // Executes DSM function via Software SMI.
  //
  // Input:
  //   Arg0: DIMM string
  //   Arg1: Function Index
  //   Arg2: Function Input
  //   Arg3: _ADR of target DIMM
  //
  // Output: per NVDIMM DSM spec
  //
  Method (CLDC, 4, Serialized)
  {
    ToInteger (Arg1, Local2)
    ToInteger (Arg3, Local4)
    //
    // Store Function Index and NFIT Device Handle
    //
    ACQUIRE (NMTX, 0xFFFF)
    Store (Local2, FUNI)
    Store (Local4, NFHD)

    //
    // Arg2 is a package usually with paramagers buffer, or empty buffer if no parameters,
    // but Arg2 can be also empty package.
    //
    If (SizeOf (Arg2)) {
  
      ToBuffer (DeRefOf (Index (Arg2, 0)), Local3)
      If (LLessEqual (SizeOf (Local3), DSM_INPB_SIZE)) {
  
        Store (SizeOf (Local3), INPL)  // Store input length in INPL bitfield for SMI handler
        Store (Local3, INPB)           // Store data in INPB for SMI handler
  
      } Else {
        //
        // Size of Arg2 is bigger than buffer for communication with SMI handler.
        // Return invalid parameters error.
        //
        RELEASE (NMTX)
        Return (Buffer() {DSM_STS_INVALID_PARAMS, 0, 0, 0})
      }
    } Else {
      //
      // Empty package passed in Arg2, put zero in input length.
      //
      Store (0, INPL)
    }
    //
    // Generate software SMI
    //
    CSMI (DCPMM_DSM_SWSMI)
    //
    // Create return buffer. Return buffer starts with 4 bytes long status followed by data
    // returned by SMI handler in OUTB buffer of OUTL length.
    //
    Name (RETB, Buffer (Add (OUTL, 4)) {} )
  
    // Update Status
    CreateDwordField (RETB, 0x00, STAT) // Status
    Store (NFST, STAT)
  
    // Copy buffer
    If (LNotEqual (OUTL, 0)) {
      CreateField (RETB, 0x20, Multiply (OUTL, 8), DATB)
      Mid (OUTB, 0, OUTL, DATB)
    }
    //
    // Return buffer
    //
    RELEASE (NMTX)
    Return (RETB)
  }


/*****************************************
 * Convert FIS status code to ACPI status.
 */
Method (CF2A, 1)
{
  Switch (ToInteger(Arg0)) {
    Case (FIS_STS_SUCCESS) {
      Return (ACPI_STS_SUCCESS)
    }
    Case (FIS_STS_INVALID_PARAM) {
      Return (ACPI_STS_INVALID_PARAMS)
    }
    Case (FIS_STS_DATA_XFER_ERR) {
      Return (ACPI_STS_RETRY_SUGGESTED)
    }
    Case (FIS_STS_INTERNAL_ERR) {
      Return (ACPI_STS_HW_ERROR)
    }
    Case (FIS_STS_UNSUPPORTED_CMD) {
      Return (ACPI_STS_NOT_IMPLEMENTED)
    }
    Case (FIS_STS_DEVICE_BUSY) {
      Return (ACPI_STS_RETRY_SUGGESTED)
    }
    Case (FIS_STS_INCORRECT_NONCE) {
      Return (ACPI_STS_UNKNOWN_ERROR)
    }
    Case (FIS_STS_INVALID_SEC_STATE) {
      Return (ACPI_STS_UNKNOWN_ERROR)
    }
    Case (FIS_STS_NO_NEW_FW) {
      Return (ACPI_STS_HW_ERROR)
    }
    Case (FIS_STS_REVISION_FAIL) {
      Return (ACPI_STS_HW_ERROR)
    }
    Case (FIS_STS_INJECT_NOT_ENABLED) {
      Return (ACPI_STS_NOT_IMPLEMENTED)
    }
    Case (FIS_STS_INVALID_ALIGNMENT) {
      Return (ACPI_STS_INVALID_PARAMS)
    }
    Case (FIS_STS_INCOMPATIBLE_DIMM) {
      Return (ACPI_STS_HW_ERROR)
    }
    Case (FIS_STS_TIMEOUT) {
      Return (ACPI_STS_RETRY_SUGGESTED)
    }
    Case (FIS_STS_MEDIA_DISABLED) {
      Return (ACPI_STS_HW_ERROR)
    }
    Case (FIS_STS_FW_UPDATE_ALREADY_OCCURRED) {
      Return (ACPI_STS_HW_ERROR)
    }
    Case (FIS_STS_NO_RESOURCES_AVAILABLE) {
      Return (ACPI_STS_HW_ERROR)
    }
    Default {
      Return (ACPI_STS_UNKNOWN_ERROR)
    }
  } // Switch
} // CF2A method


/***********************************
 * Convert FIS status code to DSM status.
 */
Method (CF2D, 1)
{
  Switch (ToInteger(Arg0)) {
    Case (FIS_STS_SUCCESS) {
      Return (DSM_STS_SUCCESS)
    }
    Case (FIS_STS_INVALID_PARAM) {
      Return (DSM_STS_INVALID_PARAMS)
    }
    Case (FIS_STS_DATA_XFER_ERR) {
      Return (DSM_STS_RETRY_SUGGESTED)
    }
    Case (FIS_STS_INTERNAL_ERR) {
      Return (DSM_STS_HW_ERROR)
    }
    Case (FIS_STS_UNSUPPORTED_CMD) {
      Return (DSM_STS_NOT_SUPPORTED)
    }
    Case (FIS_STS_DEVICE_BUSY) {
      Return (DSM_STS_RETRY_SUGGESTED)
    }
    Case (FIS_STS_INCORRECT_NONCE) {
      Return (DSM_STS_INVPASSPHRASE)
    }
    Case (FIS_STS_INVALID_SEC_STATE) {
      Return (DSM_STS_INVSECSTATE)
    }
    Case (FIS_STS_NO_NEW_FW) {
      Return (DSM_STS_HW_ERROR)
    }
    Case (FIS_STS_REVISION_FAIL) {
      Return (DSM_STS_HW_ERROR)
    }
    Case (FIS_STS_INJECT_NOT_ENABLED) {
      Return (DSM_STS_NOT_SUPPORTED)
    }
    Case (FIS_STS_INVALID_ALIGNMENT) {
      Return (DSM_STS_INVALID_PARAMS)
    }
    Case (FIS_STS_INCOMPATIBLE_DIMM) {
      Return (DSM_STS_HW_ERROR)
    }
    Case (FIS_STS_TIMEOUT) {
      Return (DSM_STS_RETRY_SUGGESTED)
    }
    Case (FIS_STS_MEDIA_DISABLED) {
      Return (DSM_STS_HW_ERROR)
    }
    Case (FIS_STS_FW_UPDATE_ALREADY_OCCURRED) {
      Return (DSM_STS_HW_ERROR)
    }
    Case (FIS_STS_NO_RESOURCES_AVAILABLE) {
      Return (DSM_STS_OUTOFRESOURCES)
    }
    Default {
      Return (DSM_STS_UNKNOWN_FAIL)
    }
  } // Switch
} // CF2D method


  //
  // Crystal Ridge Get Timeout (CGTM)
  //
  // Gets timeout for specified mailbox command.
  //
  // Input:
  //   Arg0: Opcode
  //   Arg1: Mailbox Status Register
  //
  // Output: timeout value in 100ns units
  //
  Method (CGTM, 2)
  {
    ToInteger (Arg0, Local0)
    And (Local0, 0xFF, Local1)
    if (LEqual (Local1, FIS_CMD_SET_SECURITY_MAJOR)) { // if it is one of set security commands
      Store (Local1, Local0)
    }
    switch (Local0) {
      case (Package () {FIS_CMD_GET_PLATFORM_CONFIG, FIS_CMD_SET_PLATFORM_CONFIG}) {
        Store (200000, Local2) // 20 ms
      }
      case (Package () {FIS_CMD_SET_SECURITY_MAJOR, FIS_CMD_INJECT_SW_TRIGGER}) {
        Store (1000000, Local2) // 100 ms
      }
      case (Package () {FIS_CMD_GET_FIRMWARE_DEBUG, FIS_CMD_UPDATE_FIRMWARE}) {
        Store (2000000, Local2) // 200 ms
      }
      default {
        Store (40000, Local2) // 4 ms for all others
      }
    }
    if (And (Arg1, 0x04)) {
      //
      // if long operation is in progress, bump timeout by 50 ms
      //
      Add (Local2, 500000, Local2)
    }
    if (And (Arg1, 0x08)) {
      //
      // if MB Rate Limited, bump timeout by 2ms
      //
      Add (Local2, 20000, Local2)
    }
    Return (Local2)
  }

#define WRITE_ONE_INPUT_PAYLOAD_REG(_SRCBUF, _SRCOFFSET, _REGNUM, _REGLEFT, _TEMP) \
        if (LLessEqual (_REGLEFT, 0)) { \
          Break \
        } \
        ToInteger(Mid (_SRCBUF, _SRCOFFSET, 8), _TEMP) \
        Store (_TEMP, IN ## _REGNUM) \
        Store (0xFFFFFFFFFFFFFFFF, FL01) \
        Store (0xFFFFFFFFFFFFFFFF, FL02) \
        Store (0xFFFFFFFFFFFFFFFF, FL03) \
        Store (0xFFFFFFFFFFFFFFFF, FL04) \
        Store (0xFFFFFFFFFFFFFFFF, FL05) \
        Store (0xFFFFFFFFFFFFFFFF, FL06) \
        Store (0xFFFFFFFFFFFFFFFF, FL07) \
        Store (0xFFFFFFFFFFFFFFFF, FL08) \
        Store (0xFFFFFFFFFFFFFFFF, FL09) \
        Store (0xFFFFFFFFFFFFFFFF, FL0A) \
        Store (0xFFFFFFFFFFFFFFFF, FL0B) \
        Store (0xFFFFFFFFFFFFFFFF, FL0C) \
        Store (0xFFFFFFFFFFFFFFFF, FL0D) \
        Store (0xFFFFFFFFFFFFFFFF, FL0E) \
        Store (0xFFFFFFFFFFFFFFFF, FL0F) \
        Store (0xFFFFFFFFFFFFFFFF, FL10) \
        Store (0xFFFFFFFFFFFFFFFF, FL11) \
        Store (0xFFFFFFFFFFFFFFFF, FL12) \
        Store (0xFFFFFFFFFFFFFFFF, FL13) \
        Store (0xFFFFFFFFFFFFFFFF, FL14) \
        Store (0xFFFFFFFFFFFFFFFF, FL15) \
        Store (0xFFFFFFFFFFFFFFFF, FL16) \
        Store (0xFFFFFFFFFFFFFFFF, FL17) \
        Store (0xFFFFFFFFFFFFFFFF, FL18) \
        Store (0xFFFFFFFFFFFFFFFF, FL19) \
        Store (0xFFFFFFFFFFFFFFFF, FL1A) \
        Store (0xFFFFFFFFFFFFFFFF, FL1B) \
        Store (0xFFFFFFFFFFFFFFFF, FL1C) \
        Store (0xFFFFFFFFFFFFFFFF, FL1D) \
        Store (0xFFFFFFFFFFFFFFFF, FL1E) \
        Store (0xFFFFFFFFFFFFFFFF, FL1F) \
        Store (0xFFFFFFFFFFFFFFFF, FL20) \
        Store (FL20, _TEMP) \
        Decrement (_REGLEFT) \
        Add (_SRCOFFSET, 8, _SRCOFFSET)

#define READ_ONE_OUTPUT_PAYLOAD_REG(_REGNUM, _REGLEFT) \
        if (LLessEqual (_REGLEFT, 0)) { \
          Break \
        } \
        Store (OU ## _REGNUM, BO ## _REGNUM) \
        Decrement (_REGLEFT)

//
// Definition: Crystal Ridge Leaf DSM (CRLD)
//
// Defines leaf DSM entry point method.
//
// Input:
//   Arg0: GUID
//   Arg1: Revision
//   Arg2: Function Index
//   Arg3: Function Input
//   Arg4: _ADR of target DIMM
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CRLD(_DIMM)                                  \
  Method (CRLD, 5, Serialized)                              \
  {                                                         \
    Store (CLDP (STRINGIFY(_DIMM), Arg0, Arg1, Arg2), Local0) \
    Store (DerefOf (Index (Local0, 0)), Local1)             \
    if (LEqual (Local1, CLDP_RETURN)) {                     \
      Return (DerefOf (Index (Local0, 1)))                  \
    }                                                       \
    If (LAnd (LNotEqual (CENA, 1), LNotEqual (ToInteger (Arg2), DSM_FN_VENDOR_COMMAND))) {           \
    DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " CRLD: No NVDIMM") \
      Return (Buffer () {DSM_STS_NO_MEM_DEVICE, 0, 0, 0})   \
    }                                                       \
    Switch (ToInteger (Arg2)) {                             \
      Case (DSM_FN_GET_SMART_INFO) {                        \
        Store (CR01 (Arg3), Local0)                         \
      }                                                     \
      Case (DSM_FN_GET_SMART_THRESHOLD) {                   \
        Store (CR02 (Arg3), Local0)                         \
      }                                                     \
      Case (DSM_FN_GET_BLOCK_FLAGS) {                       \
        Store (CR03 (Arg3), Local0)                         \
      }                                                     \
      Case (DSM_FN_GET_LABEL_SIZE) {                        \
        if (And (ICTL, ICTL_LSX_ASL)) {                     \
          Store (CR04 (Arg3), Local0)                       \
        } else {                                            \
          Store (CLDC (STRINGIFY(_DIMM), Arg2, Arg3, Arg4), Local0) \
        }                                                   \
      }                                                     \
      Case (DSM_FN_GET_LABEL_DATA) {                        \
        if (And (ICTL, ICTL_LSX_ASL)) {                     \
          Store (CR05 (Arg3), Local0)                       \
        } else {                                            \
          Store (CLDC (STRINGIFY(_DIMM), Arg2, Arg3, Arg4), Local0) \
        }                                                   \
      }                                                     \
      Case (DSM_FN_SET_LABEL_DATA) {                        \
        if (And (ICTL, ICTL_LSX_ASL)) {                     \
          Store (CR06 (Arg3), Local0)                       \
        } else {                                            \
          Store (CLDC (STRINGIFY(_DIMM), Arg2, Arg3, Arg4), Local0) \
        }                                                   \
      }                                                     \
      Case (DSM_FN_GET_VENDOR_LOG_SIZE) {                   \
        Store (CR07 (Arg3), Local0)                         \
      }                                                     \
      Case (DSM_FN_VENDOR_COMMAND) {                        \
        Return (CR09 (Arg0, Arg1, Arg2, Arg3))              \
      }                                                     \
      Case (DSM_FN_ENABLE_LATCH_SYSTEM_SHUTDOWN_STATUS) {   \
        If (LGreaterEqual (CFIS, 0x0107)) {                 \
          Store (CR10 (Arg3), Local0)                       \
        } Else {                                            \
          Store (CLDC (STRINGIFY(_DIMM), Arg2, Arg3, Arg4), Local0) \
        }                                                   \
      }                                                     \
      Case (DSM_FN_GET_SUPP_MODES) {                        \
        Store (CR11 (Arg3), Local0)                         \
      }                                                     \
      Case (DSM_FN_SET_SMART_THRESHOLD) {                   \
        Store (CR17 (Arg3), Local0)                         \
      }                                                     \
      Case (DSM_FN_INJECT_ERROR) {                          \
        Store (CR18 (Arg3), Local0)                         \
      }                                                     \
      Case (DSM_FN_GET_SECURITY_STATE) {                    \
        Store (CR19 (Arg3), Local0)                         \
      }                                                     \
      Case (DSM_FN_SET_PASSPHRASE) {                        \
        Store (CR20 (Arg3), Local0)                         \
      }                                                     \
      Case (DSM_FN_DISABLE_PASSPHRASE) {                    \
        Store (CR21 (Arg3), Local0)                         \
      }                                                     \
      Case (DSM_FN_UNLOCK_UNIT) {                           \
        Store (CR22 (Arg3), Local0)                         \
      }                                                     \
      Case (DSM_FN_FREEZE_LOCK) {                           \
        Store (CR23 (Arg3), Local0)                         \
      }                                                     \
      Case (DSM_FN_SECURE_ERASE_NVDIMM_USER) {              \
        Store (CR24 (Arg3), Local0)                         \
      }                                                     \
      Case (DSM_FN_QUERY_OVERVRITE_STATUS) {                \
        Store (CR26 (Arg3), Local0)                         \
      }                                                     \
      Case (DSM_FN_SET_MASTERPASSPHRASE) {                  \
        Store (CR27 (Arg3), Local0)                         \
      }                                                     \
      Case (DSM_FN_SECURE_ERASE_NVDIMM_MASTER) {            \
        Store (CR28 (Arg3), Local0)                         \
      }                                                     \
      Default {                                             \
        Store (CLDC (STRINGIFY(_DIMM), Arg2, Arg3, Arg4), Local0) \
      }                                                     \
    }                                                       \
    Return (Local0)                                         \
  }  // CRLD()

//
// Definition of Get SMART and Health Info (index: 1)
//
// Input:
//   Arg0: DSM Function Input (according to NVDIMM DSM spec)
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR01(_DIMM)                                                      \
  Method (CR01, 1, Serialized)                                                  \
  {                                                                             \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " GetSmartAndHealthInfo") \
                                                                                \
    If (LNotEqual (SizeOf (Arg0), 0)) {                                         \
                                                                                \
      /* Store input args in Local0 to be sure this is buffer */                \
      ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                              \
                                                                                \
      /* This function doesn't have input params */                             \
      if (LNotEqual (SizeOf (Local7), 0)) {                                     \
        Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                    \
      }                                                                         \
    }                                                                           \
                                                                                \
    /* Preparing output buffer in Local0 */                                     \
    Store (Buffer (132) {}, Local0)                                             \
    /* Output: Offset 0 [2B+2B]: Status + Ext. Sts */                           \
    CreateDWordField (Local0, 0, RSTS)                                          \
                                                                                \
    /* Output: Offset 4 [128B]: Smart and Health Data */                        \
    CreateField (Local0, 32, 1024, RSHD)                              \
                                                                                \
    /* Sending SMART and Health Info command to dimm - result in Local1 */      \
    Store (CMBC (FIS_CMD_SMART_AND_HEALTH_INFO, Buffer () {0,0,0,0}, Zero), Local1) \
                                                                                \
    /* Check cmd sending status */                                              \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Check cmd response status */                                             \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Cmd output: SMART and Health Info [128B] */                              \
    CreateField (DerefOf (Index (Local1, 2)), 0, 0x400, CSHI)                   \
                                                                                \
    /* Copy cmd response to output */                                           \
    Store (CSHI, RSHD)                                                          \
                                                                                \
    Return (Local0)                                                             \
  }


//
// Definition of Get SMART Threshold (index: 2)
//
// Input:
//   Arg0: DSM Function Input (according to NVDIMM DSM spec)
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR02(_DIMM)                                                  \
  Method (CR02, 1, Serialized)                                              \
  {                                                                         \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " GetSmartThreshold") \
                                                                            \
    If (LNotEqual (SizeOf (Arg0), 0)) {                                     \
                                                                            \
      /* Store input args in Local0 to be sure this is buffer */            \
      ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                          \
                                                                            \
      /* This function doesn't have input params */                         \
      if (LNotEqual (SizeOf (Local7), 0)) {                                 \
        Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                \
      }                                                                     \
    }                                                                       \
                                                                            \
    /* Preparing output buffer in Local0 */                                 \
    Store (Buffer (12) {}, Local0)                                          \
    /* Output: Offset 0 [2B+2B]: Status + Ext. Sts */                       \
    CreateDWordField (Local0, 0, RSTS)                                      \
                                                                            \
    /* Output: Offset 4 [8B]: Smart Threshold Data */                       \
    CreateQWordField (Local0, 4, RSTD)                                      \
                                                                            \
    /* Sending Alarm Thresholds command to dimm - result in Local1 */       \
    Store (CMBC (FIS_CMD_GET_ALARM_THRESHOLD, Buffer () {0,0,0,0}, Zero), Local1) \
                                                                            \
    /* Check cmd sending status */                                          \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                        \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                \
      Return (Local0)                                                       \
    }                                                                       \
                                                                            \
    /* Check cmd response status */                                         \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                        \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                \
      Return (Local0)                                                       \
    }                                                                       \
                                                                            \
    /* Create reference on Alarm Threshold response payload [8B] */         \
    CreateQWordField (DerefOf (Index (Local1, 2)), 0, CSTD)                 \
                                                                            \
    /* Copy cmd response to output */                                       \
    Store (CSTD, RSTD)                                                      \
                                                                            \
    Return (Local0)                                                         \
  }

//
// Definition of Get Block NVDIMM Flags (index: 3)
//
// Input:
//   Arg0: DSM Function Input (according to NVDIMM DSM spec)
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR03(_DIMM)                                                      \
  Method (CR03, 1, Serialized)                                                  \
  {                                                                             \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " GetBlockNvdimmFlags") \
                                                                                \
    If (LNotEqual (SizeOf (Arg0), 0)) {                                         \
                                                                                \
      /* Store input args in Local0 to be sure this is buffer */                \
      ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                              \
                                                                                \
      /* This function doesn't have input params */                             \
      if (LNotEqual (SizeOf (Local7), 0)) {                                     \
        Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                    \
      }                                                                         \
    }                                                                           \
                                                                                \
    /* Preparing output buffer in Local0 */                                     \
    Store (Buffer (8) {}, Local0)                                               \
    /* Output: Offset 0 [2B+2B]: Status + Ext. Sts */                           \
    CreateDWordField (Local0, 0, RSTS)                                          \
                                                                                \
    /* Output: Offset 4 [4B]: NVDIMM Flags */                                   \
    /* - bit0 - Block Data Window Invalidation Required */                      \
    CreateBitField (Local0, 0x20, RBIR)                                         \
    /* - bit1 - Command Register in Block Control Window Latch */               \
    CreateBitField (Local0, 0x21, RBWL)                                         \
                                                                                \
                                                                                \
    /* Sending Identify (DIMM) command to dimm - result in Local1 */            \
    Store (CMBC (FIS_CMD_IDENTIFY_DIMM, Buffer () {0,0,0,0}, Zero), Local1)     \
                                                                                \
    /* Check cmd sending status */                                              \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Check cmd response status */                                             \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Cmd response: Offset 14 [1B]: Feature SW Required Mask (FSWR): */        \
    /* - bit0: IBBRO - Invalidate Before Block Read */                          \
    CreateBitField (DerefOf (Index (Local1, 2)), 0x70, CBIR)                    \
    /* - bit1: RBWR - Readback of BW Address Register required before use */    \
    CreateBitField (DerefOf (Index (Local1, 2)), 0x71, CBWL)                    \
                                                                                \
    /* Copy cmd response to output */                                           \
    Store (CBIR, RBIR)                                                          \
    Store (CBWL, RBWL)                                                          \
                                                                                \
    Return (Local0)                                                             \
  }

//
// Definition of Get Namespace Label Size (index: 4)
//
// Input:
//   Arg0: DSM Function Input (according to NVDIMM DSM spec)
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR04(_DIMM)                                                      \
  Method (CR04, 1, Serialized)                                                  \
  {                                                                             \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelSize") \
                                                                                \
    If (LNotEqual (SizeOf (Arg0), 0)) {                                         \
                                                                                \
      /* Store input args in Local0 to be sure this is buffer */                \
      ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                              \
                                                                                \
      /* This function doesn't have input params */                             \
      if (LNotEqual (SizeOf (Local7), 0)) {                                     \
        DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelSize: unexpected input parameter") \
        Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                    \
      }                                                                         \
    }                                                                           \
                                                                                \
    /* Preparing output buffer in Local0 */                                     \
    Store (Buffer (12) {}, Local0)                                              \
    /* Output: Offset 0 [2B]: Status */                                         \
    CreateWordField (Local0, 0, RSTS)                                           \
    /* Output: Offset 2 [2B]: Ext. Status */                                    \
    CreateWordField (Local0, 2, REST)                                           \
    /* Output: Offset 4 [4B]: Size of Namespace Label Area */                   \
    CreateDWordField (Local0, 4, RSNA)                                          \
    /* Output: Offset 8 [4B]: Max Namespace Label Data Length*/                 \
    CreateDWordField (Local0, 8, RMDL)                                          \
                                                                                \
                                                                                \
    /* Read Namespace Label Size */                                             \
    Store ( PCDS (), Local1)                                                    \
    CreateWordField (Local1, 0, CSTS)                                           \
    if (LNotEqual (CSTS, DSM_STS_SUCCESS)) {                                    \
      Store (CSTS, RSTS)                                                        \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelSize: PCDS failed, returning ", ToHexString (Local0)) \
      Return (Local0)                                                           \
    }                                                                           \
    CreateDWordField (Local1, 2, CPSZ)                                          \
                                                                                \
    /* Sending Get Security State command to dimm - result in Local3 */         \
    Store (CMBC (FIS_CMD_GET_SECURITY_STATE, Buffer () {0,0,0,0}, Zero), Local3)\
                                                                                \
    /* Check cmd sending status */                                              \
    Store (CF2D (DerefOf (Index (Local3, 0))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      /* Point to ext. status */                                                \
      Store (DSM_STS_SUCCESS, RSTS)                                             \
      /* Set Locked Persistent Memory Region bit in Ext. Status */              \
      Store (0x01, REST)                                                        \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelSize: returning ", ToHexString (Local0)) \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Check cmd response status */                                             \
    Store (CF2D (DerefOf (Index (Local3, 1))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      /* Point to ext. status */                                                \
      Store (DSM_STS_SUCCESS, RSTS)                                             \
      /* Set Locked Persistent Memory Region bit in Ext. Status */              \
      Store (0x01, REST)                                                        \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelSize: returning ", ToHexString (Local0)) \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Parse cmd response payload */                                            \
    /* Cmd output Offset 0 [1B]: Security Status */                             \
    /* - bit2 - Security Locked */                                              \
    CreateBitField (DerefOf (Index (Local3, 2)), 2, CSSL)                       \
    if (LEqual (CSSL, 1)) {                                                     \
      /* Point to ext. status */                                                \
      Store (DSM_STS_SUCCESS, RSTS)                                             \
      /* Set Locked Persistent Memory Region bit in Ext. Status */              \
      Store (0x01, REST)                                                        \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelSize: locked PMEM region") \
    }                                                                           \
                                                                                \
    /* Set output values */                                                     \
    Store (CPSZ, RSNA)                                                          \
    /* MAX chunk size is NAMESPACE_DATA_CHUNK_MAX_SIZE */                       \
    Store (NAMESPACE_DATA_CHUNK_MAX_SIZE, RMDL)                                 \
                                                                                \
    DEBUG3 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelSize: returning ", ToHexString (Local0)) \
                                                                                \
    Return (Local0)                                                             \
  }

//
// Definition of Get Namespace Label Data (index: 5)
//
// Input:
//   Arg0: DSM Function Input (according to NVDIMM DSM spec)
//
// Output: per NVDIMM DSM spec
//
#define READ_ONE_PCD_CHUNK(_LENGTHLEFT, _SRCOFFSET, _TEMP, _OUTPUTFIELD) \
      if (LEqual(_LENGTHLEFT, Zero)) { \
        Break \
      } \
      Store(PCDR(_SRCOFFSET), _TEMP) \
      if (LNotEqual (DerefOf(Index(_TEMP,0)), DSM_STS_SUCCESS)) { \
        Break \
      } \
      Store(DerefOf(Index(_TEMP, 1)), _OUTPUTFIELD) \
      Subtract(_LENGTHLEFT, NAMESPACE_DATA_READ_CHUNK_SIZE, _LENGTHLEFT) \
      Add(_SRCOFFSET, NAMESPACE_DATA_READ_CHUNK_SIZE, _SRCOFFSET)


#define DEFINE_CR05(_DIMM)                                                      \
  Method (CR05, 1, Serialized)                                                  \
  {                                                                             \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelData") \
                                                                                \
    If (LEqual (SizeOf (Arg0), 0)) {                                            \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelData: no elements in input package") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
                                                                                \
    /* Input: stored in Local7 */                                               \
    ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                                \
                                                                                \
    /* Input: has 8B size */                                                    \
    if (LNotEqual (SizeOf (Local7), 8)) {                                       \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelData: invalid input size: ", ToHexString(SizeOf (Local7))) \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
                                                                                \
    DEBUG3 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelData: input: ", ToHexString(Local7)) \
                                                                                \
    /* Input: Offset 0 [4B]: Offset */                                          \
    CreateDWordField (Local7, 0, IOFF)                                          \
    /* Input: Offset 4 [4B]: Length (chunk size) */                             \
    CreateDWordField (Local7, 4, ILEN)                                          \
                                                                                \
    /* Parse value: ILEN <= NAMESPACE_DATA_CHUNK_MAX_SIZE (see CR_04 for details) */ \
    if (LGreater (ILEN, NAMESPACE_DATA_CHUNK_MAX_SIZE)) {                       \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelData: request size too big: ", ToHexString(ILEN)) \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    } ElseIf (LLessEqual (ILEN, 0)) {                                           \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelData: request size zero") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
                                                                                \
    /* Preparing output buffer in Local0 (size dep. on ILEN val.) in Local0 */  \
    Store (Buffer (Add (ILEN, 4)) {}, Local0)                                   \
    /* Output: Offset 0 [2B] Status */                                          \
    CreateWordField (Local0, 0, RSTS)                                           \
    /* Output: Offset 2 [2B] Ext. Status */                                     \
    CreateWordField (Local0, 2, REST)                                           \
                                                                                \
    /* Output: Offset 4 [(ILEN)B]: Namespace Label Data */                      \
    CreateField (Local0, 32, ShiftLeft (ILEN, 3), RDTA)                         \
                                                                                \
                                                                                \
    /* Check security state */                                                  \
    /* Sending Get Security State command to dimm - result in Local1 */         \
    Store (CMBC (FIS_CMD_GET_SECURITY_STATE, Buffer () {0,0,0,0}, Zero), Local1) \
                                                                                \
    /* Check cmd sending status */                                              \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      /* Enable ext. status */                                                  \
      Store (DSM_STS_VEN_SPECIFIC_ERROR, RSTS)                                  \
      /* Set Locked Persistent Memory Region bit in Ext. Status */              \
      Store (0x01, REST)                                                        \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelData: returning ", ToHexString (Mid(Local0, 0, MAX_DUMP_SIZE))) \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Check cmd response status */                                             \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      /* Enable ext. status */                                                  \
      Store (DSM_STS_VEN_SPECIFIC_ERROR, RSTS)                                  \
      /* Set Locked Persistent Memory Region bit in Ext. Status */              \
      Store (0x01, REST)                                                        \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelData: returning ", ToHexString (Mid(Local0, 0, MAX_DUMP_SIZE))) \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Parse cmd response payload */                                            \
    /* Cmd output: Offset 0 [1B]: Security Status */                            \
    /* - bit2 - Security Locked */                                              \
    CreateBitField (DerefOf (Index (Local1, 2)), 2, CSSL)                       \
    if (LEqual (CSSL, 1)) {                                                     \
      /* Enable ext. status */                                                  \
      Store (DSM_STS_VEN_SPECIFIC_ERROR, RSTS)                                  \
      /* Set Locked Persistent Memory Region bit in Ext. Status */              \
      Store (0x01, REST)                                                        \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelData: locked PMEM region, returning ", ToHexString (Mid(Local0, 0, MAX_DUMP_SIZE))) \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
                                                                                \
    /* Lets first check allowed offset value */                                 \
                                                                                \
    /* Read Namespace Label Size */                                             \
    Store ( PCDS (), Local1)                                                    \
    CreateWordField (Local1, 0, CSTS)                                           \
    if (LNotEqual (CSTS, DSM_STS_SUCCESS)) {                                    \
      Store (CSTS, RSTS)                                                        \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelData: PCDS failed, returning ", ToHexString (Mid(Local0, 0, MAX_DUMP_SIZE))) \
      Return (Local0)                                                           \
    }                                                                           \
    CreateDWordField (Local1, 2, CPSZ)                                          \
                                                                                \
    /* Validate input offset */                                                 \
    /* Check if requested offset+length not exceed the partition size */        \
    if (LGreater ( Add (IOFF,ILEN), CPSZ)) {                                    \
        /* Requested data chunk exceeds data size */                            \
        Store (DSM_STS_INVALID_PARAMS, RSTS)                                    \
        DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelData: request end offset too big: ", Add (IOFF,ILEN)) \
        Return (Local0)                                                         \
    }                                                                           \
                                                                                \
    /* OK, we can read data only in 128B chunks from offsets aligned to 128B */ \
                                                                                \
    /* buffer for chunks data */                                                \
    Name (BUFF, Buffer (NAMESPACE_DATA_CHUNK_MAX_SIZE_PAD) {})        \
    CreateField (BUFF, 0, 1024, LC00) \
    CreateField (BUFF, 1024, 1024, LC01) \
    CreateField (BUFF, 2048, 1024, LC02) \
    CreateField (BUFF, 3072, 1024, LC03) \
    CreateField (BUFF, 4096, 1024, LC04) \
    CreateField (BUFF, 5120, 1024, LC05) \
    CreateField (BUFF, 6144, 1024, LC06) \
    CreateField (BUFF, 7168, 1024, LC07) \
    CreateField (BUFF, 8192, 1024, LC08) \
    CreateField (BUFF, 9216, 1024, LC09) \
    CreateField (BUFF, 10240, 1024, LC0A) \
    CreateField (BUFF, 11264, 1024, LC0B) \
    CreateField (BUFF, 12288, 1024, LC0C) \
    CreateField (BUFF, 13312, 1024, LC0D) \
    CreateField (BUFF, 14336, 1024, LC0E) \
    CreateField (BUFF, 15360, 1024, LC0F) \
    CreateField (BUFF, 16384, 1024, LC10) \
    CreateField (BUFF, 17408, 1024, LC11) \
    CreateField (BUFF, 18432, 1024, LC12) \
    CreateField (BUFF, 19456, 1024, LC13) \
    CreateField (BUFF, 20480, 1024, LC14) \
    CreateField (BUFF, 21504, 1024, LC15) \
    CreateField (BUFF, 22528, 1024, LC16) \
    CreateField (BUFF, 23552, 1024, LC17) \
    CreateField (BUFF, 24576, 1024, LC18) \
    CreateField (BUFF, 25600, 1024, LC19) \
    CreateField (BUFF, 26624, 1024, LC1A) \
    CreateField (BUFF, 27648, 1024, LC1B) \
    CreateField (BUFF, 28672, 1024, LC1C) \
    CreateField (BUFF, 29696, 1024, LC1D) \
    CreateField (BUFF, 30720, 1024, LC1E) \
    CreateField (BUFF, 31744, 1024, LC1F) \
    CreateField (BUFF, 32768, 1024, LC20) \
    CreateField (BUFF, 33792, 1024, LC21) \
    CreateField (BUFF, 34816, 1024, LC22) \
    CreateField (BUFF, 35840, 1024, LC23) \
    CreateField (BUFF, 36864, 1024, LC24) \
    CreateField (BUFF, 37888, 1024, LC25) \
    CreateField (BUFF, 38912, 1024, LC26) \
    CreateField (BUFF, 39936, 1024, LC27) \
    CreateField (BUFF, 40960, 1024, LC28) \
    CreateField (BUFF, 41984, 1024, LC29) \
    CreateField (BUFF, 43008, 1024, LC2A) \
    CreateField (BUFF, 44032, 1024, LC2B) \
    CreateField (BUFF, 45056, 1024, LC2C) \
    CreateField (BUFF, 46080, 1024, LC2D) \
    CreateField (BUFF, 47104, 1024, LC2E) \
    CreateField (BUFF, 48128, 1024, LC2F) \
    CreateField (BUFF, 49152, 1024, LC30) \
    CreateField (BUFF, 50176, 1024, LC31) \
    CreateField (BUFF, 51200, 1024, LC32) \
    CreateField (BUFF, 52224, 1024, LC33) \
    CreateField (BUFF, 53248, 1024, LC34) \
    CreateField (BUFF, 54272, 1024, LC35) \
    CreateField (BUFF, 55296, 1024, LC36) \
    CreateField (BUFF, 56320, 1024, LC37) \
    CreateField (BUFF, 57344, 1024, LC38) \
    CreateField (BUFF, 58368, 1024, LC39) \
    CreateField (BUFF, 59392, 1024, LC3A) \
    CreateField (BUFF, 60416, 1024, LC3B) \
    CreateField (BUFF, 61440, 1024, LC3C) \
    CreateField (BUFF, 62464, 1024, LC3D) \
    CreateField (BUFF, 63488, 1024, LC3E) \
    CreateField (BUFF, 64512, 1024, LC3F) \
    CreateField (BUFF, 65536, 1024, LC40) \
    CreateField (BUFF, 66560, 1024, LC41) \
    CreateField (BUFF, 67584, 1024, LC42) \
    CreateField (BUFF, 68608, 1024, LC43) \
    CreateField (BUFF, 69632, 1024, LC44) \
    CreateField (BUFF, 70656, 1024, LC45) \
    CreateField (BUFF, 71680, 1024, LC46) \
    CreateField (BUFF, 72704, 1024, LC47) \
    CreateField (BUFF, 73728, 1024, LC48) \
    CreateField (BUFF, 74752, 1024, LC49) \
    CreateField (BUFF, 75776, 1024, LC4A) \
    CreateField (BUFF, 76800, 1024, LC4B) \
    CreateField (BUFF, 77824, 1024, LC4C) \
    CreateField (BUFF, 78848, 1024, LC4D) \
    CreateField (BUFF, 79872, 1024, LC4E) \
    CreateField (BUFF, 80896, 1024, LC4F) \
    CreateField (BUFF, 81920, 1024, LC50) \
    CreateField (BUFF, 82944, 1024, LC51) \
    CreateField (BUFF, 83968, 1024, LC52) \
    CreateField (BUFF, 84992, 1024, LC53) \
    CreateField (BUFF, 86016, 1024, LC54) \
    CreateField (BUFF, 87040, 1024, LC55) \
    CreateField (BUFF, 88064, 1024, LC56) \
    CreateField (BUFF, 89088, 1024, LC57) \
    CreateField (BUFF, 90112, 1024, LC58) \
    CreateField (BUFF, 91136, 1024, LC59) \
    CreateField (BUFF, 92160, 1024, LC5A) \
    CreateField (BUFF, 93184, 1024, LC5B) \
    CreateField (BUFF, 94208, 1024, LC5C) \
    CreateField (BUFF, 95232, 1024, LC5D) \
    CreateField (BUFF, 96256, 1024, LC5E) \
    CreateField (BUFF, 97280, 1024, LC5F) \
    CreateField (BUFF, 98304, 1024, LC60) \
    CreateField (BUFF, 99328, 1024, LC61) \
    CreateField (BUFF, 100352, 1024, LC62) \
    CreateField (BUFF, 101376, 1024, LC63) \
    CreateField (BUFF, 102400, 1024, LC64) \
    CreateField (BUFF, 103424, 1024, LC65) \
    CreateField (BUFF, 104448, 1024, LC66) \
    CreateField (BUFF, 105472, 1024, LC67) \
    CreateField (BUFF, 106496, 1024, LC68) \
    CreateField (BUFF, 107520, 1024, LC69) \
    CreateField (BUFF, 108544, 1024, LC6A) \
    CreateField (BUFF, 109568, 1024, LC6B) \
    CreateField (BUFF, 110592, 1024, LC6C) \
    CreateField (BUFF, 111616, 1024, LC6D) \
    CreateField (BUFF, 112640, 1024, LC6E) \
    CreateField (BUFF, 113664, 1024, LC6F) \
    CreateField (BUFF, 114688, 1024, LC70) \
    CreateField (BUFF, 115712, 1024, LC71) \
    CreateField (BUFF, 116736, 1024, LC72) \
    CreateField (BUFF, 117760, 1024, LC73) \
    CreateField (BUFF, 118784, 1024, LC74) \
    CreateField (BUFF, 119808, 1024, LC75) \
    CreateField (BUFF, 120832, 1024, LC76) \
    CreateField (BUFF, 121856, 1024, LC77) \
    CreateField (BUFF, 122880, 1024, LC78) \
    CreateField (BUFF, 123904, 1024, LC79) \
    CreateField (BUFF, 124928, 1024, LC7A) \
    CreateField (BUFF, 125952, 1024, LC7B) \
    CreateField (BUFF, 126976, 1024, LC7C) \
    CreateField (BUFF, 128000, 1024, LC7D) \
    CreateField (BUFF, 129024, 1024, LC7E) \
    CreateField (BUFF, 130048, 1024, LC7F) \
    CreateField (BUFF, 131072, 1024, LC80) \
    CreateField (BUFF, 132096, 1024, LC81) \
    CreateField (BUFF, 133120, 1024, LC82) \
    CreateField (BUFF, 134144, 1024, LC83) \
    CreateField (BUFF, 135168, 1024, LC84) \
    CreateField (BUFF, 136192, 1024, LC85) \
    CreateField (BUFF, 137216, 1024, LC86) \
    CreateField (BUFF, 138240, 1024, LC87) \
    CreateField (BUFF, 139264, 1024, LC88) \
    CreateField (BUFF, 140288, 1024, LC89) \
    CreateField (BUFF, 141312, 1024, LC8A) \
    CreateField (BUFF, 142336, 1024, LC8B) \
    CreateField (BUFF, 143360, 1024, LC8C) \
    CreateField (BUFF, 144384, 1024, LC8D) \
    CreateField (BUFF, 145408, 1024, LC8E) \
    CreateField (BUFF, 146432, 1024, LC8F) \
    CreateField (BUFF, 147456, 1024, LC90) \
    CreateField (BUFF, 148480, 1024, LC91) \
    CreateField (BUFF, 149504, 1024, LC92) \
    CreateField (BUFF, 150528, 1024, LC93) \
    CreateField (BUFF, 151552, 1024, LC94) \
    CreateField (BUFF, 152576, 1024, LC95) \
    CreateField (BUFF, 153600, 1024, LC96) \
    CreateField (BUFF, 154624, 1024, LC97) \
    CreateField (BUFF, 155648, 1024, LC98) \
    CreateField (BUFF, 156672, 1024, LC99) \
    CreateField (BUFF, 157696, 1024, LC9A) \
    CreateField (BUFF, 158720, 1024, LC9B) \
    CreateField (BUFF, 159744, 1024, LC9C) \
    CreateField (BUFF, 160768, 1024, LC9D) \
    CreateField (BUFF, 161792, 1024, LC9E) \
    CreateField (BUFF, 162816, 1024, LC9F) \
    CreateField (BUFF, 163840, 1024, LCA0) \
    CreateField (BUFF, 164864, 1024, LCA1) \
    CreateField (BUFF, 165888, 1024, LCA2) \
    CreateField (BUFF, 166912, 1024, LCA3) \
    CreateField (BUFF, 167936, 1024, LCA4) \
    CreateField (BUFF, 168960, 1024, LCA5) \
    CreateField (BUFF, 169984, 1024, LCA6) \
    CreateField (BUFF, 171008, 1024, LCA7) \
    CreateField (BUFF, 172032, 1024, LCA8) \
    CreateField (BUFF, 173056, 1024, LCA9) \
    CreateField (BUFF, 174080, 1024, LCAA) \
    CreateField (BUFF, 175104, 1024, LCAB) \
    CreateField (BUFF, 176128, 1024, LCAC) \
    CreateField (BUFF, 177152, 1024, LCAD) \
    CreateField (BUFF, 178176, 1024, LCAE) \
    CreateField (BUFF, 179200, 1024, LCAF) \
    CreateField (BUFF, 180224, 1024, LCB0) \
    CreateField (BUFF, 181248, 1024, LCB1) \
    CreateField (BUFF, 182272, 1024, LCB2) \
    CreateField (BUFF, 183296, 1024, LCB3) \
    CreateField (BUFF, 184320, 1024, LCB4) \
    CreateField (BUFF, 185344, 1024, LCB5) \
    CreateField (BUFF, 186368, 1024, LCB6) \
    CreateField (BUFF, 187392, 1024, LCB7) \
    CreateField (BUFF, 188416, 1024, LCB8) \
    CreateField (BUFF, 189440, 1024, LCB9) \
    CreateField (BUFF, 190464, 1024, LCBA) \
    CreateField (BUFF, 191488, 1024, LCBB) \
    CreateField (BUFF, 192512, 1024, LCBC) \
    CreateField (BUFF, 193536, 1024, LCBD) \
    CreateField (BUFF, 194560, 1024, LCBE) \
    CreateField (BUFF, 195584, 1024, LCBF) \
    CreateField (BUFF, 196608, 1024, LCC0) \
    CreateField (BUFF, 197632, 1024, LCC1) \
    CreateField (BUFF, 198656, 1024, LCC2) \
    CreateField (BUFF, 199680, 1024, LCC3) \
    CreateField (BUFF, 200704, 1024, LCC4) \
    CreateField (BUFF, 201728, 1024, LCC5) \
    CreateField (BUFF, 202752, 1024, LCC6) \
    CreateField (BUFF, 203776, 1024, LCC7) \
    CreateField (BUFF, 204800, 1024, LCC8) \
    CreateField (BUFF, 205824, 1024, LCC9) \
    CreateField (BUFF, 206848, 1024, LCCA) \
    CreateField (BUFF, 207872, 1024, LCCB) \
    CreateField (BUFF, 208896, 1024, LCCC) \
    CreateField (BUFF, 209920, 1024, LCCD) \
    CreateField (BUFF, 210944, 1024, LCCE) \
    CreateField (BUFF, 211968, 1024, LCCF) \
    CreateField (BUFF, 212992, 1024, LCD0) \
    CreateField (BUFF, 214016, 1024, LCD1) \
    CreateField (BUFF, 215040, 1024, LCD2) \
    CreateField (BUFF, 216064, 1024, LCD3) \
    CreateField (BUFF, 217088, 1024, LCD4) \
    CreateField (BUFF, 218112, 1024, LCD5) \
    CreateField (BUFF, 219136, 1024, LCD6) \
    CreateField (BUFF, 220160, 1024, LCD7) \
    CreateField (BUFF, 221184, 1024, LCD8) \
    CreateField (BUFF, 222208, 1024, LCD9) \
    CreateField (BUFF, 223232, 1024, LCDA) \
    CreateField (BUFF, 224256, 1024, LCDB) \
    CreateField (BUFF, 225280, 1024, LCDC) \
    CreateField (BUFF, 226304, 1024, LCDD) \
    CreateField (BUFF, 227328, 1024, LCDE) \
    CreateField (BUFF, 228352, 1024, LCDF) \
    CreateField (BUFF, 229376, 1024, LCE0) \
    CreateField (BUFF, 230400, 1024, LCE1) \
    CreateField (BUFF, 231424, 1024, LCE2) \
    CreateField (BUFF, 232448, 1024, LCE3) \
    CreateField (BUFF, 233472, 1024, LCE4) \
    CreateField (BUFF, 234496, 1024, LCE5) \
    CreateField (BUFF, 235520, 1024, LCE6) \
    CreateField (BUFF, 236544, 1024, LCE7) \
    CreateField (BUFF, 237568, 1024, LCE8) \
    CreateField (BUFF, 238592, 1024, LCE9) \
    CreateField (BUFF, 239616, 1024, LCEA) \
    CreateField (BUFF, 240640, 1024, LCEB) \
    CreateField (BUFF, 241664, 1024, LCEC) \
    CreateField (BUFF, 242688, 1024, LCED) \
    CreateField (BUFF, 243712, 1024, LCEE) \
    CreateField (BUFF, 244736, 1024, LCEF) \
    CreateField (BUFF, 245760, 1024, LCF0) \
    CreateField (BUFF, 246784, 1024, LCF1) \
    CreateField (BUFF, 247808, 1024, LCF2) \
    CreateField (BUFF, 248832, 1024, LCF3) \
    CreateField (BUFF, 249856, 1024, LCF4) \
    CreateField (BUFF, 250880, 1024, LCF5) \
    CreateField (BUFF, 251904, 1024, LCF6) \
    CreateField (BUFF, 252928, 1024, LCF7) \
    CreateField (BUFF, 253952, 1024, LCF8) \
    CreateField (BUFF, 254976, 1024, LCF9) \
    CreateField (BUFF, 256000, 1024, LCFA) \
    CreateField (BUFF, 257024, 1024, LCFB) \
    CreateField (BUFF, 258048, 1024, LCFC) \
    CreateField (BUFF, 259072, 1024, LCFD) \
    CreateField (BUFF, 260096, 1024, LCFE) \
    CreateField (BUFF, 261120, 1024, LCFF) \
    CreateField (BUFF, 262144, 1024, LD00) \
    CreateField (BUFF, 263168, 1024, LD01) \
    CreateField (BUFF, 264192, 1024, LD02) \
    CreateField (BUFF, 265216, 1024, LD03) \
    CreateField (BUFF, 266240, 1024, LD04) \
    CreateField (BUFF, 267264, 1024, LD05) \
    CreateField (BUFF, 268288, 1024, LD06) \
    CreateField (BUFF, 269312, 1024, LD07) \
    CreateField (BUFF, 270336, 1024, LD08) \
    CreateField (BUFF, 271360, 1024, LD09) \
    CreateField (BUFF, 272384, 1024, LD0A) \
    CreateField (BUFF, 273408, 1024, LD0B) \
    CreateField (BUFF, 274432, 1024, LD0C) \
    CreateField (BUFF, 275456, 1024, LD0D) \
    CreateField (BUFF, 276480, 1024, LD0E) \
    CreateField (BUFF, 277504, 1024, LD0F) \
    CreateField (BUFF, 278528, 1024, LD10) \
    CreateField (BUFF, 279552, 1024, LD11) \
    CreateField (BUFF, 280576, 1024, LD12) \
    CreateField (BUFF, 281600, 1024, LD13) \
    CreateField (BUFF, 282624, 1024, LD14) \
    CreateField (BUFF, 283648, 1024, LD15) \
    CreateField (BUFF, 284672, 1024, LD16) \
    CreateField (BUFF, 285696, 1024, LD17) \
    CreateField (BUFF, 286720, 1024, LD18) \
    CreateField (BUFF, 287744, 1024, LD19) \
    CreateField (BUFF, 288768, 1024, LD1A) \
    CreateField (BUFF, 289792, 1024, LD1B) \
    CreateField (BUFF, 290816, 1024, LD1C) \
    CreateField (BUFF, 291840, 1024, LD1D) \
    CreateField (BUFF, 292864, 1024, LD1E) \
    CreateField (BUFF, 293888, 1024, LD1F) \
    CreateField (BUFF, 294912, 1024, LD20) \
    CreateField (BUFF, 295936, 1024, LD21) \
    CreateField (BUFF, 296960, 1024, LD22) \
    CreateField (BUFF, 297984, 1024, LD23) \
    CreateField (BUFF, 299008, 1024, LD24) \
    CreateField (BUFF, 300032, 1024, LD25) \
    CreateField (BUFF, 301056, 1024, LD26) \
    CreateField (BUFF, 302080, 1024, LD27) \
    CreateField (BUFF, 303104, 1024, LD28) \
    CreateField (BUFF, 304128, 1024, LD29) \
    CreateField (BUFF, 305152, 1024, LD2A) \
    CreateField (BUFF, 306176, 1024, LD2B) \
    CreateField (BUFF, 307200, 1024, LD2C) \
    CreateField (BUFF, 308224, 1024, LD2D) \
    CreateField (BUFF, 309248, 1024, LD2E) \
    CreateField (BUFF, 310272, 1024, LD2F) \
    CreateField (BUFF, 311296, 1024, LD30) \
    CreateField (BUFF, 312320, 1024, LD31) \
    CreateField (BUFF, 313344, 1024, LD32) \
    CreateField (BUFF, 314368, 1024, LD33) \
    CreateField (BUFF, 315392, 1024, LD34) \
    CreateField (BUFF, 316416, 1024, LD35) \
    CreateField (BUFF, 317440, 1024, LD36) \
    CreateField (BUFF, 318464, 1024, LD37) \
    CreateField (BUFF, 319488, 1024, LD38) \
    CreateField (BUFF, 320512, 1024, LD39) \
    CreateField (BUFF, 321536, 1024, LD3A) \
    CreateField (BUFF, 322560, 1024, LD3B) \
    CreateField (BUFF, 323584, 1024, LD3C) \
    CreateField (BUFF, 324608, 1024, LD3D) \
    CreateField (BUFF, 325632, 1024, LD3E) \
    CreateField (BUFF, 326656, 1024, LD3F) \
    CreateField (BUFF, 327680, 1024, LD40) \
    CreateField (BUFF, 328704, 1024, LD41) \
    CreateField (BUFF, 329728, 1024, LD42) \
    CreateField (BUFF, 330752, 1024, LD43) \
    CreateField (BUFF, 331776, 1024, LD44) \
    CreateField (BUFF, 332800, 1024, LD45) \
    CreateField (BUFF, 333824, 1024, LD46) \
    CreateField (BUFF, 334848, 1024, LD47) \
    CreateField (BUFF, 335872, 1024, LD48) \
    CreateField (BUFF, 336896, 1024, LD49) \
    CreateField (BUFF, 337920, 1024, LD4A) \
    CreateField (BUFF, 338944, 1024, LD4B) \
    CreateField (BUFF, 339968, 1024, LD4C) \
    CreateField (BUFF, 340992, 1024, LD4D) \
    CreateField (BUFF, 342016, 1024, LD4E) \
    CreateField (BUFF, 343040, 1024, LD4F) \
    CreateField (BUFF, 344064, 1024, LD50) \
    CreateField (BUFF, 345088, 1024, LD51) \
    CreateField (BUFF, 346112, 1024, LD52) \
    CreateField (BUFF, 347136, 1024, LD53) \
    CreateField (BUFF, 348160, 1024, LD54) \
    CreateField (BUFF, 349184, 1024, LD55) \
    CreateField (BUFF, 350208, 1024, LD56) \
    CreateField (BUFF, 351232, 1024, LD57) \
    CreateField (BUFF, 352256, 1024, LD58) \
    CreateField (BUFF, 353280, 1024, LD59) \
    CreateField (BUFF, 354304, 1024, LD5A) \
    CreateField (BUFF, 355328, 1024, LD5B) \
    CreateField (BUFF, 356352, 1024, LD5C) \
    CreateField (BUFF, 357376, 1024, LD5D) \
    CreateField (BUFF, 358400, 1024, LD5E) \
    CreateField (BUFF, 359424, 1024, LD5F) \
    CreateField (BUFF, 360448, 1024, LD60) \
    CreateField (BUFF, 361472, 1024, LD61) \
    CreateField (BUFF, 362496, 1024, LD62) \
    CreateField (BUFF, 363520, 1024, LD63) \
    CreateField (BUFF, 364544, 1024, LD64) \
    CreateField (BUFF, 365568, 1024, LD65) \
    CreateField (BUFF, 366592, 1024, LD66) \
    CreateField (BUFF, 367616, 1024, LD67) \
    CreateField (BUFF, 368640, 1024, LD68) \
    CreateField (BUFF, 369664, 1024, LD69) \
    CreateField (BUFF, 370688, 1024, LD6A) \
    CreateField (BUFF, 371712, 1024, LD6B) \
    CreateField (BUFF, 372736, 1024, LD6C) \
    CreateField (BUFF, 373760, 1024, LD6D) \
    CreateField (BUFF, 374784, 1024, LD6E) \
    CreateField (BUFF, 375808, 1024, LD6F) \
    CreateField (BUFF, 376832, 1024, LD70) \
    CreateField (BUFF, 377856, 1024, LD71) \
    CreateField (BUFF, 378880, 1024, LD72) \
    CreateField (BUFF, 379904, 1024, LD73) \
    CreateField (BUFF, 380928, 1024, LD74) \
    CreateField (BUFF, 381952, 1024, LD75) \
    CreateField (BUFF, 382976, 1024, LD76) \
    CreateField (BUFF, 384000, 1024, LD77) \
    CreateField (BUFF, 385024, 1024, LD78) \
    CreateField (BUFF, 386048, 1024, LD79) \
    CreateField (BUFF, 387072, 1024, LD7A) \
    CreateField (BUFF, 388096, 1024, LD7B) \
    CreateField (BUFF, 389120, 1024, LD7C) \
    CreateField (BUFF, 390144, 1024, LD7D) \
    CreateField (BUFF, 391168, 1024, LD7E) \
    CreateField (BUFF, 392192, 1024, LD7F) \
    CreateField (BUFF, 393216, 1024, LD80) \
    CreateField (BUFF, 394240, 1024, LD81) \
    CreateField (BUFF, 395264, 1024, LD82) \
    CreateField (BUFF, 396288, 1024, LD83) \
    CreateField (BUFF, 397312, 1024, LD84) \
    CreateField (BUFF, 398336, 1024, LD85) \
    CreateField (BUFF, 399360, 1024, LD86) \
    CreateField (BUFF, 400384, 1024, LD87) \
    CreateField (BUFF, 401408, 1024, LD88) \
    CreateField (BUFF, 402432, 1024, LD89) \
    CreateField (BUFF, 403456, 1024, LD8A) \
    CreateField (BUFF, 404480, 1024, LD8B) \
    CreateField (BUFF, 405504, 1024, LD8C) \
    CreateField (BUFF, 406528, 1024, LD8D) \
    CreateField (BUFF, 407552, 1024, LD8E) \
    CreateField (BUFF, 408576, 1024, LD8F) \
    CreateField (BUFF, 409600, 1024, LD90) \
    CreateField (BUFF, 410624, 1024, LD91) \
    CreateField (BUFF, 411648, 1024, LD92) \
    CreateField (BUFF, 412672, 1024, LD93) \
    CreateField (BUFF, 413696, 1024, LD94) \
    CreateField (BUFF, 414720, 1024, LD95) \
    CreateField (BUFF, 415744, 1024, LD96) \
    CreateField (BUFF, 416768, 1024, LD97) \
    CreateField (BUFF, 417792, 1024, LD98) \
    CreateField (BUFF, 418816, 1024, LD99) \
    CreateField (BUFF, 419840, 1024, LD9A) \
    CreateField (BUFF, 420864, 1024, LD9B) \
    CreateField (BUFF, 421888, 1024, LD9C) \
    CreateField (BUFF, 422912, 1024, LD9D) \
    CreateField (BUFF, 423936, 1024, LD9E) \
    CreateField (BUFF, 424960, 1024, LD9F) \
    CreateField (BUFF, 425984, 1024, LDA0) \
    CreateField (BUFF, 427008, 1024, LDA1) \
    CreateField (BUFF, 428032, 1024, LDA2) \
    CreateField (BUFF, 429056, 1024, LDA3) \
    CreateField (BUFF, 430080, 1024, LDA4) \
    CreateField (BUFF, 431104, 1024, LDA5) \
    CreateField (BUFF, 432128, 1024, LDA6) \
    CreateField (BUFF, 433152, 1024, LDA7) \
    CreateField (BUFF, 434176, 1024, LDA8) \
    CreateField (BUFF, 435200, 1024, LDA9) \
    CreateField (BUFF, 436224, 1024, LDAA) \
    CreateField (BUFF, 437248, 1024, LDAB) \
    CreateField (BUFF, 438272, 1024, LDAC) \
    CreateField (BUFF, 439296, 1024, LDAD) \
    CreateField (BUFF, 440320, 1024, LDAE) \
    CreateField (BUFF, 441344, 1024, LDAF) \
    CreateField (BUFF, 442368, 1024, LDB0) \
    CreateField (BUFF, 443392, 1024, LDB1) \
    CreateField (BUFF, 444416, 1024, LDB2) \
    CreateField (BUFF, 445440, 1024, LDB3) \
    CreateField (BUFF, 446464, 1024, LDB4) \
    CreateField (BUFF, 447488, 1024, LDB5) \
    CreateField (BUFF, 448512, 1024, LDB6) \
    CreateField (BUFF, 449536, 1024, LDB7) \
    CreateField (BUFF, 450560, 1024, LDB8) \
    CreateField (BUFF, 451584, 1024, LDB9) \
    CreateField (BUFF, 452608, 1024, LDBA) \
    CreateField (BUFF, 453632, 1024, LDBB) \
    CreateField (BUFF, 454656, 1024, LDBC) \
    CreateField (BUFF, 455680, 1024, LDBD) \
    CreateField (BUFF, 456704, 1024, LDBE) \
    CreateField (BUFF, 457728, 1024, LDBF) \
    CreateField (BUFF, 458752, 1024, LDC0) \
    CreateField (BUFF, 459776, 1024, LDC1) \
    CreateField (BUFF, 460800, 1024, LDC2) \
    CreateField (BUFF, 461824, 1024, LDC3) \
    CreateField (BUFF, 462848, 1024, LDC4) \
    CreateField (BUFF, 463872, 1024, LDC5) \
    CreateField (BUFF, 464896, 1024, LDC6) \
    CreateField (BUFF, 465920, 1024, LDC7) \
    CreateField (BUFF, 466944, 1024, LDC8) \
    CreateField (BUFF, 467968, 1024, LDC9) \
    CreateField (BUFF, 468992, 1024, LDCA) \
    CreateField (BUFF, 470016, 1024, LDCB) \
    CreateField (BUFF, 471040, 1024, LDCC) \
    CreateField (BUFF, 472064, 1024, LDCD) \
    CreateField (BUFF, 473088, 1024, LDCE) \
    CreateField (BUFF, 474112, 1024, LDCF) \
    CreateField (BUFF, 475136, 1024, LDD0) \
    CreateField (BUFF, 476160, 1024, LDD1) \
    CreateField (BUFF, 477184, 1024, LDD2) \
    CreateField (BUFF, 478208, 1024, LDD3) \
    CreateField (BUFF, 479232, 1024, LDD4) \
    CreateField (BUFF, 480256, 1024, LDD5) \
    CreateField (BUFF, 481280, 1024, LDD6) \
    CreateField (BUFF, 482304, 1024, LDD7) \
    CreateField (BUFF, 483328, 1024, LDD8) \
    CreateField (BUFF, 484352, 1024, LDD9) \
    CreateField (BUFF, 485376, 1024, LDDA) \
    CreateField (BUFF, 486400, 1024, LDDB) \
    CreateField (BUFF, 487424, 1024, LDDC) \
    CreateField (BUFF, 488448, 1024, LDDD) \
    CreateField (BUFF, 489472, 1024, LDDE) \
    CreateField (BUFF, 490496, 1024, LDDF) \
    CreateField (BUFF, 491520, 1024, LDE0) \
    CreateField (BUFF, 492544, 1024, LDE1) \
    CreateField (BUFF, 493568, 1024, LDE2) \
    CreateField (BUFF, 494592, 1024, LDE3) \
    CreateField (BUFF, 495616, 1024, LDE4) \
    CreateField (BUFF, 496640, 1024, LDE5) \
    CreateField (BUFF, 497664, 1024, LDE6) \
    CreateField (BUFF, 498688, 1024, LDE7) \
    CreateField (BUFF, 499712, 1024, LDE8) \
    CreateField (BUFF, 500736, 1024, LDE9) \
    CreateField (BUFF, 501760, 1024, LDEA) \
    CreateField (BUFF, 502784, 1024, LDEB) \
    CreateField (BUFF, 503808, 1024, LDEC) \
    CreateField (BUFF, 504832, 1024, LDED) \
    CreateField (BUFF, 505856, 1024, LDEE) \
    CreateField (BUFF, 506880, 1024, LDEF) \
    CreateField (BUFF, 507904, 1024, LDF0) \
    CreateField (BUFF, 508928, 1024, LDF1) \
    CreateField (BUFF, 509952, 1024, LDF2) \
    CreateField (BUFF, 510976, 1024, LDF3) \
    CreateField (BUFF, 512000, 1024, LDF4) \
    CreateField (BUFF, 513024, 1024, LDF5) \
    CreateField (BUFF, 514048, 1024, LDF6) \
    CreateField (BUFF, 515072, 1024, LDF7) \
    CreateField (BUFF, 516096, 1024, LDF8) \
    CreateField (BUFF, 517120, 1024, LDF9) \
    CreateField (BUFF, 518144, 1024, LDFA) \
    CreateField (BUFF, 519168, 1024, LDFB) \
    CreateField (BUFF, 520192, 1024, LDFC) \
    CreateField (BUFF, 521216, 1024, LDFD) \
    CreateField (BUFF, 522240, 1024, LDFE) \
    \
    And(IOFF, Not(NAMESPACE_DATA_READ_CHUNK_SIZE_MASK), Local3) \
    Subtract(And(Add(Add(ILEN, IOFF),NAMESPACE_DATA_READ_CHUNK_SIZE_MASK),Not(NAMESPACE_DATA_READ_CHUNK_SIZE_MASK)), Local3, Local2) \
    Subtract(IOFF, Local3, Local5) \
    while (1) { \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC00) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC01) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC02) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC03) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC04) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC05) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC06) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC07) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC08) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC09) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC0A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC0B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC0C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC0D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC0E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC0F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC10) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC11) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC12) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC13) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC14) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC15) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC16) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC17) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC18) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC19) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC1A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC1B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC1C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC1D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC1E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC1F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC20) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC21) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC22) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC23) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC24) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC25) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC26) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC27) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC28) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC29) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC2A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC2B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC2C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC2D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC2E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC2F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC30) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC31) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC32) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC33) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC34) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC35) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC36) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC37) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC38) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC39) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC3A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC3B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC3C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC3D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC3E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC3F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC40) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC41) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC42) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC43) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC44) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC45) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC46) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC47) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC48) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC49) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC4A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC4B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC4C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC4D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC4E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC4F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC50) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC51) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC52) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC53) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC54) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC55) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC56) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC57) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC58) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC59) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC5A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC5B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC5C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC5D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC5E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC5F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC60) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC61) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC62) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC63) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC64) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC65) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC66) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC67) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC68) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC69) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC6A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC6B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC6C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC6D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC6E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC6F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC70) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC71) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC72) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC73) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC74) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC75) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC76) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC77) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC78) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC79) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC7A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC7B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC7C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC7D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC7E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC7F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC80) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC81) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC82) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC83) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC84) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC85) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC86) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC87) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC88) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC89) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC8A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC8B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC8C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC8D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC8E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC8F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC90) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC91) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC92) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC93) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC94) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC95) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC96) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC97) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC98) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC99) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC9A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC9B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC9C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC9D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC9E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LC9F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCA0) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCA1) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCA2) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCA3) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCA4) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCA5) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCA6) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCA7) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCA8) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCA9) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCAA) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCAB) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCAC) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCAD) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCAE) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCAF) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCB0) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCB1) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCB2) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCB3) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCB4) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCB5) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCB6) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCB7) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCB8) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCB9) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCBA) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCBB) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCBC) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCBD) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCBE) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCBF) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCC0) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCC1) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCC2) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCC3) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCC4) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCC5) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCC6) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCC7) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCC8) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCC9) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCCA) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCCB) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCCC) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCCD) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCCE) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCCF) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCD0) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCD1) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCD2) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCD3) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCD4) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCD5) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCD6) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCD7) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCD8) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCD9) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCDA) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCDB) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCDC) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCDD) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCDE) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCDF) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCE0) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCE1) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCE2) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCE3) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCE4) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCE5) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCE6) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCE7) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCE8) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCE9) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCEA) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCEB) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCEC) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCED) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCEE) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCEF) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCF0) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCF1) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCF2) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCF3) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCF4) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCF5) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCF6) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCF7) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCF8) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCF9) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCFA) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCFB) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCFC) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCFD) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCFE) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LCFF) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD00) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD01) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD02) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD03) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD04) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD05) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD06) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD07) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD08) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD09) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD0A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD0B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD0C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD0D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD0E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD0F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD10) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD11) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD12) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD13) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD14) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD15) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD16) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD17) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD18) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD19) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD1A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD1B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD1C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD1D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD1E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD1F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD20) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD21) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD22) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD23) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD24) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD25) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD26) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD27) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD28) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD29) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD2A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD2B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD2C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD2D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD2E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD2F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD30) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD31) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD32) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD33) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD34) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD35) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD36) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD37) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD38) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD39) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD3A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD3B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD3C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD3D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD3E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD3F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD40) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD41) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD42) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD43) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD44) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD45) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD46) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD47) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD48) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD49) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD4A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD4B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD4C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD4D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD4E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD4F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD50) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD51) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD52) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD53) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD54) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD55) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD56) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD57) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD58) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD59) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD5A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD5B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD5C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD5D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD5E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD5F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD60) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD61) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD62) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD63) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD64) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD65) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD66) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD67) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD68) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD69) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD6A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD6B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD6C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD6D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD6E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD6F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD70) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD71) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD72) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD73) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD74) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD75) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD76) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD77) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD78) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD79) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD7A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD7B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD7C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD7D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD7E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD7F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD80) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD81) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD82) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD83) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD84) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD85) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD86) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD87) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD88) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD89) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD8A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD8B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD8C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD8D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD8E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD8F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD90) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD91) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD92) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD93) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD94) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD95) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD96) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD97) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD98) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD99) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD9A) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD9B) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD9C) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD9D) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD9E) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LD9F) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDA0) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDA1) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDA2) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDA3) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDA4) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDA5) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDA6) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDA7) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDA8) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDA9) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDAA) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDAB) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDAC) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDAD) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDAE) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDAF) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDB0) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDB1) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDB2) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDB3) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDB4) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDB5) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDB6) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDB7) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDB8) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDB9) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDBA) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDBB) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDBC) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDBD) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDBE) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDBF) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDC0) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDC1) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDC2) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDC3) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDC4) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDC5) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDC6) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDC7) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDC8) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDC9) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDCA) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDCB) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDCC) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDCD) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDCE) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDCF) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDD0) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDD1) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDD2) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDD3) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDD4) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDD5) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDD6) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDD7) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDD8) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDD9) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDDA) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDDB) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDDC) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDDD) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDDE) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDDF) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDE0) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDE1) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDE2) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDE3) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDE4) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDE5) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDE6) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDE7) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDE8) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDE9) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDEA) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDEB) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDEC) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDED) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDEE) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDEF) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDF0) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDF1) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDF2) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDF3) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDF4) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDF5) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDF6) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDF7) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDF8) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDF9) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDFA) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDFB) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDFC) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDFD) \
      READ_ONE_PCD_CHUNK(Local2, Local3, Local4, LDFE) \
      Break \
    } \
    if (LNotEqual(Local2, Zero)) { \
      Store(DerefOf(Index(Local4,0)), RSTS) \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelData: read loop error, returning ", ToHexString (Mid(Local0, 0, MAX_DUMP_SIZE))) \
      Return (Local0) \
    } \
    \
    Mid(BUFF, Local5, ILEN, RDTA) \
    DEBUG3 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " GetNamespaceLabelData: returning ", ToHexString (Mid(Local0, 0, MAX_DUMP_SIZE))) \
    Return (Local0)                                                             \
  }

//
// Definition of Set Namespace Label Data (index: 6)
//
// Input:
//   Arg0: DSM Function Input (according to NVDIMM DSM spec)
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR06(_DIMM)                                                      \
  Method (CR06, 1, Serialized)                                                  \
  {                                                                             \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData") \
                                                                                \
    If (LEqual (SizeOf (Arg0), 0)) {                                            \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: no elements in input package") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
                                                                                \
    /* Input: stored in Local7 */                                               \
    ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                                \
                                                                                \
    /* Input has var. size but at least 8B */                                   \
    if (LLess (SizeOf (Local7), 8)) {                                           \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: invalid input size: ", ToHexString(SizeOf (Local7))) \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
                                                                                \
    DEBUG3 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: input: ", ToHexString(Mid (Local7, 0, MAX_DUMP_SIZE))) \
                                                                                \
    /* Input: Offset 0 [4B]: Offset */                                          \
    CreateDWordField (Local7, 0, IOFF)                                          \
                                                                                \
    /* Input: Offset 4 [4B]: Length */                                          \
    CreateDWordField (Local7, 4, ILEN)                                          \
    /* Check if ILEN value is not higher than max chunk value */                \
    /* (see CR_04 for details) */                                               \
    if (LGreater (ILEN, NAMESPACE_DATA_CHUNK_MAX_SIZE)) {                       \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: request size too big: ", ToHexString(ILEN)) \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    } ElseIf (LLessEqual (ILEN, 0)) {                                           \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: request size zero") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
                                                                                \
    /* ILEN value is valid, check the input buffer size */                      \
    if (LLess (SizeOf (Local7), Add (ILEN, 8))) {                               \
        /* buffer is too small to containning defined input data */             \
        DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: request size overruns input size ", ToHexString (SizeOf (Local7))) \
        Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                    \
    }                                                                           \
    /* Input: Offset 8 [<ILEN>B]: Namespace Label Data */                       \
    CreateField (Local7, 64, ShiftLeft (ILEN, 3), IDTA)                         \
                                                                                \
                                                                                \
    /* Preparing output buffer in Local0 */                                     \
    Store (Buffer (4) {}, Local0)                                               \
    /* Output: Offset 0 [2B] Status */                                          \
    CreateWordField (Local0, 0, RSTS)                                           \
    /* Output: Offset 2 [2B] Ext. Status */                                     \
    CreateWordField (Local0, 2, REST)                                           \
                                                                                \
                                                                                \
    /* Check security state */                                                  \
    /* Sending Get Security State command to dimm - result in Local1 */         \
    Store (CMBC (FIS_CMD_GET_SECURITY_STATE, Buffer () {0,0,0,0}, Zero), Local1)\
                                                                                \
    /* Check cmd sending status */                                              \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      /* Enable ext. status */                                                  \
      Store (DSM_STS_VEN_SPECIFIC_ERROR, RSTS)                                  \
      /* Set Locked Persistent Memory Region bit in Ext. Status */              \
      Store (0x01, REST)                                                        \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: returning ", ToHexString (Local0)) \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Check cmd response status */                                             \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      /* Enable ext. status */                                                  \
      Store (DSM_STS_VEN_SPECIFIC_ERROR, RSTS)                                  \
      /* Set Locked Persistent Memory Region bit in Ext. Status */              \
      Store (0x01, REST)                                                        \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: returning ", ToHexString (Local0)) \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Parse cmd response payload */                                            \
    /* Cmd output: Offset 0 [1B]: Security Status */                            \
    /* - bit2 - Security Locked */                                              \
    CreateBitField (DerefOf (Index (Local1, 2)), 2, CSSL)                       \
    if (LEqual (CSSL, 1)) {                                                     \
      /* Enable ext. status */                                                  \
      Store (DSM_STS_VEN_SPECIFIC_ERROR, RSTS)                                  \
      /* Set Locked Persistent Memory Region bit in Ext. Status */              \
      Store (0x01, REST)                                                        \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: locked PMEM region, returning ", ToHexString (Local0)) \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
                                                                                \
    /* Lets first check allowed offset value */                                 \
    Store ( PCDS (), Local1)                                                    \
    CreateWordField (Local1, 0, CSTS)                                           \
    if (LNotEqual (CSTS, DSM_STS_SUCCESS)) {                                    \
      Store (CSTS, RSTS)                                                        \
      DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: PCDS failed, returning ", ToHexString (Local0)) \
      Return (Local0)                                                           \
    }                                                                           \
    CreateDWordField (Local1, 2, CPSZ)                                          \
                                                                                \
                                                                                \
    /* Validate input offset */                                                 \
    /* Check if requested offset+data-len not exceed the partition size */      \
    if (LGreater (Add (IOFF, ILEN), CPSZ)) {                                    \
        /* Requested offset is higher than data size */                         \
        Store (DSM_STS_INVALID_PARAMS, RSTS)                                    \
        DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: request end offset too big: ", ToHexString(Add (IOFF,ILEN))) \
        Return (Local0)                                                         \
    }                                                                           \
                                                                                \
    And (Add (IOFF, NAMESPACE_DATA_WRITE_CHUNK_SIZE_MASK), Not (NAMESPACE_DATA_WRITE_CHUNK_SIZE_MASK), Local3) \
    Add (IOFF, ILEN, Local2) \
    And (Local2, Not (NAMESPACE_DATA_WRITE_CHUNK_SIZE_MASK), Local5) \
    Subtract (Local3, IOFF, Local4) \
    Subtract (Local2, Local5, Local2) \
    \
    /* Local3: adjusted IOFF */ \
    /* Local5: adjusted END */ \
    /* Local4: bytes of the leading (partial) buffer */ \
    /* Local2: bytes of the trailing (partial) buffer */ \
    \
    if (Local4) { \
      if (LGreater (Local4, ILEN)) { \
        /* do not attempt to write more bytes than available */ \
        Store (ILEN, Local4) \
      } \
      And (IOFF, Not(NAMESPACE_DATA_READ_CHUNK_SIZE_MASK), Local2) \
      Store (PCDR (Local2), Local1) \
      Store (DerefOf(Index(Local1, 0)), RSTS) \
      if (LNotEqual (RSTS, DSM_STS_SUCCESS)) { \
        DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: lead read returning ", ToHexString (Local0)) \
        Return (Local0) \
      } \
      Store (DerefOf(Index(Local1, 1)), Local1) \
      Subtract (IOFF, Local2, Local2) \
      CreateField (Local1, ShiftLeft (Local2, 3), ShiftLeft(Local4, 3), LBUF) \
      CreateField (Local1, 0, NAMESPACE_DATA_WRITE_CHUNK_SIZE_BITS, LB01) \
      CreateField (Local1, NAMESPACE_DATA_WRITE_CHUNK_SIZE_BITS, NAMESPACE_DATA_WRITE_CHUNK_SIZE_BITS, LB02) \
      Mid (IDTA, 0, Local4, LBUF) \
      And (IOFF, Not(NAMESPACE_DATA_READ_CHUNK_SIZE_MASK), Local2) \
      Store (PCDW (Local2, LB01), RSTS) \
      if (LNotEqual (RSTS, DSM_STS_SUCCESS)) { \
        DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: lead write A returning ", ToHexString (Local0)) \
        Return (Local0) \
      } \
      Add (Local2, NAMESPACE_DATA_WRITE_CHUNK_SIZE, Local2) \
      Store (PCDW (Local2, LB02), RSTS) \
      if (LNotEqual (RSTS, DSM_STS_SUCCESS)) { \
        DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: lead write B returning ", ToHexString (Local0)) \
        Return (Local0) \
      } \
      Add (IOFF, ILEN, Local2) \
      Subtract (Local2, Local5, Local2) \
    } \
    if (LAnd (Local2, LGreater (ILEN, Local2))) { \
      /* only execute if trailing buffer is larger than ILEN */ \
      And (Local5, Not(NAMESPACE_DATA_READ_CHUNK_SIZE_MASK), Local4) \
      Store (PCDR (Local4), Local1) \
      Store (DerefOf(Index(Local1, 0)), RSTS) \
      if (LNotEqual (RSTS, DSM_STS_SUCCESS)) { \
        DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: trail read returning ", ToHexString (Local0)) \
        Return (Local0) \
      } \
      Store (DerefOf(Index(Local1, 1)), Local1) \
      Subtract (Local5, Local4, Local4) \
      CreateField (Local1, ShiftLeft (Local4, 3), ShiftLeft(Local2, 3), TBUF) \
      CreateField (Local1, 0, NAMESPACE_DATA_WRITE_CHUNK_SIZE_BITS, TB01) \
      CreateField (Local1, NAMESPACE_DATA_WRITE_CHUNK_SIZE_BITS, NAMESPACE_DATA_WRITE_CHUNK_SIZE_BITS, TB02) \
      Mid (IDTA, Subtract(ILEN, Local2), Local2, TBUF) \
      And (Local5, Not(NAMESPACE_DATA_READ_CHUNK_SIZE_MASK), Local4) \
      Store (PCDW (Local4, TB01), RSTS) \
      if (LNotEqual (RSTS, DSM_STS_SUCCESS)) { \
        DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: trail write A returning ", ToHexString (Local0)) \
        Return (Local0) \
      } \
      Add (Local4, NAMESPACE_DATA_WRITE_CHUNK_SIZE, Local4) \
      Store (PCDW (Local4, TB02), RSTS) \
      if (LNotEqual (RSTS, DSM_STS_SUCCESS)) { \
        DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: trail write B returning ", ToHexString (Local0)) \
        Return (Local0) \
      } \
      Subtract (Local3, IOFF, Local4) \
    } \
    \
    while (1) { \
      if (LGreaterEqual (Local3, Local5)) { \
        break \
      } \
      Store(PCDW(Local3, Mid(IDTA, Local4, NAMESPACE_DATA_WRITE_CHUNK_SIZE)), Local1) \
      if (LNotEqual(Local1, DSM_STS_SUCCESS)) { \
        Store (Local1, RSTS) \
        DEBUG3 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: returning ", ToHexString (Local0)) \
        Return (Local0) \
      } \
      Add (Local4, NAMESPACE_DATA_WRITE_CHUNK_SIZE, Local4) \
      Add (Local3, NAMESPACE_DATA_WRITE_CHUNK_SIZE, Local3) \
    } \
                                                                                \
    DEBUG3 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " SetNamespaceLabelData: returning ", ToHexString (Local0)) \
                                                                                \
    Return (Local0)                                                             \
  }

//
// Definition of Get Command Effect Log Info (index: 7)
//
// Input:
//   Arg0: DSM Function Input (according to NVDIMM DSM spec)
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR07(_DIMM)                                                      \
  Method (CR07, 1, Serialized)                                                  \
  {                                                                             \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " GetCommandEffectLogInfo") \
                                                                                \
    If (LNotEqual (SizeOf (Arg0), 0)) {                                         \
                                                                                \
      /* Store input args in Local0 to be sure this is buffer */                \
      ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                              \
                                                                                \
      /* This function doesn't have input params */                             \
      if (LNotEqual (SizeOf (Local7), 0)) {                                     \
        Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                    \
      }                                                                         \
    }                                                                           \
                                                                                \
    /* Preparing output buffer */                                               \
    Store (Buffer (8) {}, Local0)                                               \
    /* Output: offset 0 [4B]: Status[2B] + Ext. Sts[2B]*/                       \
    /* NOT USED: CreateDWordField (Local0, 0, RSTS) */                          \
                                                                                \
    /* Output: offset 4 [4B]: Max Command Effect Log Data Length */             \
    CreateDWordField (Local0, 4, RMXL)                                          \
    /* return always 32kB */                                                    \
    Store (0x8000, RMXL)                                                        \
                                                                                \
    Return (Local0)                                                             \
  }


//
// Definition: Vendor-Specific Command DSM
//
// Input:
//   Arg0: GUID
//   Arg1: Revision
//   Arg2: Function Index
//   Arg3: Function Input
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR09(_DIMM) \
  Method (CR09, 4, Serialized) \
  { \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " PassThroughCommand") \
    if (LEqual (SizeOf (Arg3), 0)) { \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0}) \
    } \
    ToBuffer (DeRefOf (Index (Arg3, 0)), Local7) \
    Store (SizeOf (Local7), Local4) \
    if (LLess (Local4, 8)) { \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0}) \
    } \
    CreateWordField  (Local7, 0x00, OPCD) \
    CreateDwordField (Local7, 0x04, OPDL) \
    if (LNotEqual (Local4, Add (OPDL, 8))) { \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0}) \
    } \
    if (LAnd (LNotEqual (CENA, 1), LNotEqual (OPCD, FIS_CMD_EXTENDED_VEN_SPEC))) { \
      Return (Buffer () {DSM_STS_NO_MEM_DEVICE, 0, 0, 0}) \
    } \
    Switch (OPCD) { \
      Case (Package () {FIS_CMD_OVERWRITE_DIMM, FIS_CMD_SET_ADDRESS_RANGE_SCRUB, FIS_CMD_UPDATE_FIRMWARE, \
                        FIS_CMD_GET_LP_MB_INFO, FIS_CMD_WRITE_LP_INPUT_MB, FIS_CMD_READ_LP_OUTPUT_MB}) { \
        /* Long operations and emulated large payload operations are handled in SWSMI */ \
        Return (CLDC (STRINGIFY(_DIMM), Arg2, Arg3, _ADR)) \
      } \
      Case (FIS_CMD_EXTENDED_VEN_SPEC) { \
        /* Opcode 05FD is Extend Vendor Spec Command */ \
        CreateWordField (Local7, 0x08, PTCD) \
        if (LEqual (PTCD, 0)) { \
          Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0}) \
        } \
        CreateDWordField (Local7, 0x4, PTDL) \
        if (LGreaterEqual (PTDL, 0xC)) { \
          Subtract (OPDL, 0xC, PTDL) \
        } else { \
          Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0}) \
        } \
        if (LGreater (PTDL, 0)) { \
          CreateField (Local7, 0xA0, Multiply (PTDL, 8), PTIN) \
        } \
        CreateByteField (Local7, 0x0A, PTTI) \
        if (LAnd (LNotEqual (CENA, 1), LEqual (PTTI, 1))) { \
          Store (0, TFSM) \
        } \
        Switch (PTCD) { \
          Case (FIS_CMD_EXTENDED_VEN_SPEC) { \
            Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0}) \
            } \
          Case (Package () {FIS_CMD_GET_LP_MB_INFO, FIS_CMD_WRITE_LP_INPUT_MB, FIS_CMD_READ_LP_OUTPUT_MB, \
                            FIS_CMD_GET_BOOT_STATUS}) { \
            /* Long operations and emulated large payload operations are handled in SWSMI */ \
            Name (INLO, Package() {Buffer (Add (PTDL, 8)) {}}) \
            CreateWordField (DerefOf (Index (INLO, 0)), 0, LOCD) \
            CreateDWordField (DerefOf (Index (INLO, 0)), 4, LODL) \
            if (LGreater (PTDL, 0)) { \
              CreateField (DerefOf (Index (INLO, 0)), 64, Multiply (PTDL, 8), LOIN) \
              Mid (Local7, 0x14, Multiply (PTDL, 8), LOIN) \
            } \
            Mid (Local7, 8, 2, LOCD) \
            Store (PTDL, LODL) \
            if (LEqual (FIS_CMD_GET_BOOT_STATUS, LOCD)) { \
              /* Opcode 03FD is Read BSR. We got BSR exposed in ASL via Extended Vendor Specific Command */ \
              Store (10000000, TFSM) \
              Store (Buffer (16) {}, Local2) \
              CreateDwordField (Local2, 4, FDLA) \
              CreateField (Local2, 64, 64, FDDA) \
              Store (8, FDLA) \
              Store (XBSR, FDDA) \
              DEBUG3 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " BSR: ", ToHexString(FDDA)) \
              Return (Local2) \
            } \
            Return (CLDC (STRINGIFY(_DIMM), Arg2, INLO, _ADR)) \
            } \
          Case (Package () {FIS_CMD_OVERWRITE_DIMM, FIS_CMD_SET_ADDRESS_RANGE_SCRUB, FIS_CMD_UPDATE_FIRMWARE} ) { \
            /* Long operations are handled in SWSMI */ \
            if (LAnd (LNotEqual (CENA, 1), LNotEqual(PTTI, 1))) { \
              Return (Buffer () {DSM_STS_NO_MEM_DEVICE, 0, 0, 0}) \
            } \
            Return (CLDC (STRINGIFY(_DIMM), Arg2, Arg3, _ADR)) \
          } \
          Default { \
            if (LEqual (PTTI, 1)) { \
              Return (CLDC (STRINGIFY(_DIMM), Arg2, Arg3, _ADR)) \
            } \
            if (LNotEqual (CENA, 1)) { \
              Return (Buffer () {DSM_STS_NO_MEM_DEVICE, 0, 0, 0}) \
            } \
            CreateDWordField (Local7, 0x10, PTTO) \
            if (LLess (Local4, 20)) { \
              Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0}) \
            } \
            if (LGreater (PTDL, 128)) { \
              Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0}) \
            } \
            if (LEqual(PTDL, Zero)) { \
              Store (CMBC (PTCD, Buffer () {}, Zero), Local0) \
            } else { \
              Store (CMBC (PTCD, PTIN, Multiply(PTTO, 10000)), Local0) \
            } \
          } \
        } \
      } \
      Case (FIS_CMD_GET_BOOT_STATUS) { \
        /* Opcode 03FD is Read BSR. We got BSR exposed in ASL */ \
        Store (Buffer (16) {}, Local2) \
        CreateDwordField (Local2, 4, OULA) \
        CreateField (Local2, 64, 64, OUDA) \
        Store (8, OULA) \
        Store (XBSR, OUDA) \
        DEBUG3 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " BSR: ", ToHexString(OUDA)) \
        Return (Local2) \
      } \
      Default { \
        if (LGreater (OPDL, 128)) { \
          Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0}) \
        } \
        if (LEqual(OPDL, Zero)) { \
          Store (CMBC (OPCD, Buffer () {}, Zero), Local0) \
        } else { \
          CreateField (Local7, 0x40, Multiply (OPDL, 8), OPDB) \
          Store (CMBC (OPCD, OPDB, Zero), Local0) \
        } \
      } /* Default */ \
    } /* Switch */ \
    Store (DerefOf (Index (Local0, 0)), Local1) \
    if (LNotEqual (Local1, Zero)) { \
      Store (Buffer (4) {}, Local2) \
      Store (DSM_STS_RETRY_SUGGESTED, Index (Local2, 0)) \
      Return (Local2) \
    } \
    Store (DerefOf (Index (Local0, 1)), Local1) \
    if (LNotEqual (Local1, Zero)) { \
      Store (Buffer () {DSM_STS_VEN_SPECIFIC_ERROR, 0, 0, 0}, Local2) \
      Store (Local1, Index (Local2, 2)) \
      Return (Local2) \
    } \
    Store (Buffer (136) { }, Local2) \
    CreateDwordField (Local2, 4, OULB) \
    CreateField (Local2, 64, 1024, OUDB) \
    Store (128, OULB) \
    Store (DerefOf (Index (Local0, 2)), OUDB) \
    Return (Local2) \
  }

//
// Definition of Enable Latch System Shutdown Status DSM
//
// Input:
// Arg0: Buffer with just one byte
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR10(_DIMM)                                                      \
  Method (CR10, 1, Serialized)                                                  \
  {                                                                             \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " EnableLatchSystemShutdownStatus") \
    Store (Buffer (4) {DSM_STS_SUCCESS, 0, 0, 0}, Local0)                       \
    CreateDWordField (Local0, 0, RSTS)                                          \
    If (LEqual (SizeOf (Arg0), 0)) {                                            \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
    ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                                \
    If (LNotEqual (SizeOf (Local7), 1)) {                                       \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
    If (LNotEqual (DerefOf (Index (Local7, 0)), 1)) {                           \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
    Store (CMBC (FIS_CMD_SET_LATCH_SYSTEM_SHUTDOWN_STATUS, Local7, Zero), Local1)\
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                            \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      Return (Local0)                                                           \
    }                                                                           \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                            \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      Return (Local0)                                                           \
    }                                                                           \
    Return (Local0)                                                             \
  }

//
// Definition of Get Supported Modes
//
// Input:
//   Arg0: DSM Function Input (according to NVDIMM DSM spec)
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR11(_DIMM)                                                      \
  Method (CR11, 1, Serialized)                                                  \
  {                                                                             \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " GetSupportedModes") \
                                                                                \
    If (LNotEqual (SizeOf (Arg0), 0)) {                                         \
                                                                                \
      /* Store input args in Local0 to be sure this is buffer */                \
      ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                              \
                                                                                \
      /* This function doesn't have input params */                             \
      if (LNotEqual (SizeOf (Local7), 0)) {                                     \
        Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                    \
      }                                                                         \
    }                                                                           \
                                                                                \
    /* Preparing output buffer */                                               \
    Store (Buffer (6) {}, Local0)                                               \
    /* Output: Status[2B] + Ext. Sts[2B]*/                                      \
    CreateDWordField (Local0, 0, RSTS)                                          \
    /* Output: Offset 4 [2B]: Supported Modes */                                \
    /* - bit0 - Memory Mode */                                                  \
    CreateBitField (Local0, 0x20, RMMO)                                         \
    /* - bit1 - PMEM Mode supported */                                          \
    CreateBitField (Local0, 0x21, RPME)                                         \
    /* - bit2 - Block Aperture Mode supported */                                \
    CreateBitField (Local0, 0x22, RBAP)                                         \
                                                                                \
    /* Sending Identify command to dimm - result in Local1 */                   \
    Store (CMBC (FIS_CMD_IDENTIFY_DIMM, Buffer () {0,0,0,0}, Zero), Local1)     \
                                                                                \
    /* Check cmd sending status */                                              \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Check cmd response status */                                             \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Parse cmd response payload */                                            \
    Store (DerefOf (Index (Local1, 2)), Local3)                                 \
    /* Cmd output: Offset 62 [4B]: DIMM SKU (but only first byte is significant here)*/  \
    /* - bit0 - MemoryModeEn */                                                 \
    CreateBitField (Local3, 0x1F0, MEME)                                        \
    /* - bit1 - StorageModeEn */                                                \
    CreateBitField (Local3, 0x1F1, STME)                                        \
    /* - bit2 - DirectModeEn */                                                 \
    CreateBitField (Local3, 0x1F2, DTME)                                        \
                                                                                \
    /* Prepare the resoinse values */                                           \
    Store (MEME, RMMO)                                                          \
    Store (DTME, RPME)                                                          \
    Store (STME, RBAP)                                                          \
                                                                                \
    Return (Local0)                                                             \
  }

//
// Definition of Set SMART Threshold (index: 17)
//
// Input:
//   Arg0: DSM Function Input (according to NVDIMM DSM spec)
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR17(_DIMM)                                                      \
  Method (CR17, 1, Serialized)                                                  \
  {                                                                             \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " SetSmartThreshold") \
                                                                                \
    If (LEqual (SizeOf (Arg0), 0)) {                                            \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
                                                                                \
    /* Store input in Local7 */                                                 \
    ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                                \
                                                                                \
    /* Check input length */                                                    \
    if (LNotEqual (SizeOf (Local7), 7)) {                                       \
        /* Input has invalid isze */                                            \
        Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                    \
    }                                                                           \
                                                                                \
    /* Input fields: */                                                         \
    /* General field for the whole input */                                     \
    CreateField (Local7, 0, 0x38, ISMT)                                         \
                                                                                \
    /* Validate input values */                                                 \
                                                                                \
    /* Input: Offset 0 [2B] - Threshold Alarm Enable */                         \
    /* - bit0 - Percentage Remaining Threshold Alarm Enable */                  \
    CreateBitField (Local7, 0, ISBE)                                            \
    /* - bit1 - NVDIMM Media Temperature Threshold Alarm Enable */              \
    /* - bit0 - NVDIMM Controller Temperature Threshold Alarm Enable */         \
    /* - bit3-15: Reserved (should be 0) */                                     \
    CreateField (Local7, 0x3, 13, R000)                                         \
    if (LNotEqual (ToInteger (R000), 0)) {                                      \
      /* Improper reserved field value */                                       \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetSmartThreshold: non-zero reserved bits!") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
                                                                                \
    /* Check if Percentage Remaining Threshold is enabled */                    \
    if (LEqual (ISBE, 1)) {                                                     \
        /* Input: Offset 2 [1B] - Percentage Remaining Threshold */             \
        CreateByteField (Local7, 2, ISBT)                                       \
        /* Check if: 0 < ISBT < 100 */                                          \
        if ( LOr (LLess (ISBT, 1), LGreater (ISBT, 99))){                       \
            DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " SetSmartThreshold: invalid Percentage Remaining Threshold value!") \
            Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                \
        }                                                                       \
    }                                                                           \
                                                                                \
    /* Preparing output buffer in Local0 */                                     \
    Store (Buffer (4) {}, Local0)                                               \
    /* Output: Status[2B] + Ext. Sts[2B]*/                                      \
    CreateDWordField (Local0, 0, RSTS)                                          \
                                                                                \
    /* Sending Alarm Thresholds command to dimm - result in Local1 */           \
    Store (CMBC (FIS_CMD_SET_ALARM_THRESHOLD, ISMT, Zero), Local1)              \
                                                                                \
    /* Check cmd sending status */                                              \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Check cmd response status */                                             \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    Return (Local0)                                                             \
  }

//
// Definition of Inject Error (index: 18)
//
// Input:
//   Arg0: DSM Function Input (according to NVDIMM DSM spec)
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR18(_DIMM)                                                      \
  Method (CR18, 1, Serialized)                                                  \
  {                                                                             \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " InjectError")       \
                                                                                \
    If (LEqual (SizeOf (Arg0), 0)) {                                            \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
                                                                                \
    /* Store input in Local7 */                                                 \
    ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                                \
                                                                                \
    /* Check input size */                                                      \
    if (LNotEqual (SizeOf (Local7), 15)) {                                      \
      /* Improper input size */                                                 \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
                                                                                \
    /* Input fields: */                                                         \
    /* Input: offset 0 [8B]: Error Inject Validity Flags */                     \
    /*  - bit 0: Media Temperature Error Inject fields are valid */             \
    CreateBitField (Local7, 0x0, IVME)                                          \
    /*  - bit 1: Percentage Remaining Trigger fields are valid */               \
    CreateBitField (Local7, 0x1, IVSB)                                          \
    /*  - bit 2: Fatal Error Trigger fields are valid */                        \
    CreateBitField (Local7, 0x2, IVFE)                                          \
    /*  - bit 3: Dirty Shutdown Error Trigger fields are valid */               \
    CreateBitField (Local7, 0x3, IVUS)                                          \
    /*  - bits 4-63: reserved = 0 */                                            \
    CreateField(Local7, 0x4, 60, R000)                                          \
    if (LNotEqual (ToInteger (R000), 0)) {                                      \
      /* Improper reserved field value */                                       \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " InjectError: non-zero reserved bits R000!") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
                                                                                \
    /* Input: offset 8 [3B]: Media Temperature Error Inject */                  \
    /*  - bit 0: Media Temperature Errors Enabled */                            \
    CreateBitField (Local7, 0x40, IMEN)                                         \
    /*  - bits 1-7: reserved = 0 */                                             \
    CreateField (Local7, 0x41, 7, R001)                                         \
    if (LNotEqual (ToInteger (R001), 0)) {                                      \
      /* Improper reserved field value */                                       \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " InjectError: non-zero reserved bits R001!") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
    /*  - bits 8-23: Media Temperature to Inject */                             \
    CreateWordField(Local7, 9, IMMT)                                            \
                                                                                \
    /* Input: offset 11 [2B]: Percentag Remaining Inject */                     \
    /*  - bit 0: Percentage Remaining Enabled */                                \
    CreateBitField (Local7, 0x58, ISEN)                                         \
    /*  - bits 1-7: reserved = 0 */                                             \
    CreateField (Local7, 0x59, 7, R002)                                         \
    if (LNotEqual (ToInteger (R002), 0)) {                                      \
      /* Improper reserved field value */                                       \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " InjectError: non-zero reserved bits R002!") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
    /*  - bits 8-15: Percentage Remaining to inject */                          \
    CreateByteField (Local7, 12, ISSB)                                          \
    if (LOr (LLess (ISSB, 0), LGreater (ISSB, 99))) {                           \
      /* Invalid Percentage Remaining value */                                \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " InjectError: invalid Percentage Remaining value!") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
                                                                                \
    /* Input: offset 13 [1B]: Fatal Error Trigger */                            \
    /*  - bit 0: Fatal Error Trigger Enabled */                                 \
    CreateBitField (Local7, 0x68, IFEN)                                         \
    /*  - bits 1-7: reserved = 0 */                                             \
    CreateField (Local7, 0x69, 7, R003)                                         \
    if (LNotEqual (ToInteger (R003), 0)) {                                      \
      /* Improper reserved field value */                                       \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " InjectError: non-zero reserved bits R003!") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
                                                                                \
    /* Input: offset 14 [1B]: Unsafe Shutdown Error Inject */                   \
    /*  - bit 0: Unsafe Shutdown Error Inject Enabled */                        \
    CreateBitField (Local7, 0x70, IUEN)                                         \
    /*  - bits 1-7: reserved = 0 */                                             \
    CreateField (Local7, 0x71, 7, R004)                                         \
    if (LNotEqual (ToInteger (R004), 0)) {                                      \
      /* Improper reserved field value */                                       \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " InjectError: non-zero reserved bits R004!") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})                      \
    }                                                                           \
    /* Preparing output buffer in Local0 */                                     \
    Store (Buffer (4) {}, Local0)                                               \
    /* Output: Offset 0 [2B] Status */                                          \
    CreateWordField (Local0, 0, RSTS)                                           \
    /* Output: Offset 2 [2B] Ext. Status */                                     \
    CreateWordField (Local0, 2, REST)                                           \
                                                                                \
    /* if Media Temp. enabled */                                                \
    if ( LEqual (IVME, 1) ) {                                                   \
        /* Sending Media Temperature Error command to dimm - result in Local1 */\
        /* Preparing cmd input data in Local2 */                                \
        Store (Buffer (3) {}, Local2)                                           \
        /* Cmd input: offset 0 [1B]: Enable */                                  \
        CreateByteField (Local2, 0, CENB)                                       \
        Store (IMEN, CENB)                                                      \
        /* Cmd input: offset 1 [2B]: Media Temperature */                       \
        CreateWordField (Local2, 1, CMET)                                       \
        Store (IMMT, CMET)                                                      \
                                                                                \
        Store (CMBC (FIS_CMD_INJECT_MEDIA_TEMP_ERROR, Local2, Zero), Local1)    \
                                                                                \
        /* Check cmd sending status */                                          \
        Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                        \
        if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                \
          Return (Local0)                                                       \
        }                                                                       \
                                                                                \
        /* Check cmd response status */                                         \
        Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                        \
        if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                \
          Return (Local0)                                                       \
        }                                                                       \
    }                                                                           \
    /* if Percentage Remaining || Fatal Error || Unsafe Shutdown enabled */     \
    if ( LOr( LEqual (IVSB, 1), LOr( LEqual (IVFE, 1),  LEqual (IVUS, 1)) ) ) { \
        /* Sending Software Triggers command to dimm - result in Local1 */      \
        /* Preparing cmd input data in Local2 */                                \
        Store (Buffer (14) {}, Local2)                                          \
        /* Cmd input: offset 0 [7B]: Triggers to modify */                      \
        /* - bit 2: Fatal Error Trigger */                                      \
        CreateBitField (Local2, 2, CFEN)                                        \
        Store (IVFE, CFEN)                                                      \
        /* - bit 3: Percentage Remaining Trigger */                             \
        CreateBitField (Local2, 3, CSEN)                                        \
        Store (IVSB, CSEN)                                                      \
        /* - bit 4: Unsafe Shutdown Trigger */                                  \
        CreateBitField (Local2, 4, CUEN)                                        \
        Store (IVUS, CUEN)                                                      \
                                                                                \
        /* Cmd input: offset 11 [1B]: Fatal Error Trigger */                    \
        CreateByteField (Local2, 11, CFET)                                      \
        Store (IFEN, CFET)                                                      \
                                                                                \
        /* Cmd input: offset 12 [1B]: Percentage Remaining Trigger */           \
        /* - bit 0: Enable/Disable Trigger */                                   \
        CreateBitField (Local2, 0x60, CSET)                                     \
        Store (ISEN, CSET)                                                      \
        /* - bits 1-7: Percentage Remaining */                                  \
        CreateField (Local2, 0x61, 7, CSBP)                                     \
        Store (ISSB, CSBP)                                                      \
                                                                                \
        /* Cmd input: offset 13 [1B]: Unsafe Shutdown Trigger */                \
        CreateByteField (Local2, 13, CUST)                                      \
        Store (IUEN, CUST)                                                      \
        If (LAnd (IVUS, IUEN)) {                                                \
          /* If dirty shutdown is being injected enable latch to avoid error */ \
          CMBC (FIS_CMD_SET_LATCH_SYSTEM_SHUTDOWN_STATUS, Buffer () {1,0,0,0}, Zero) \
        }                                                                       \
        Store (CMBC (FIS_CMD_INJECT_SW_TRIGGER, Local2,  Zero), Local1)         \
                                                                                \
        /* Check cmd sending status */                                          \
        Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                        \
        if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                \
          Return (Local0)                                                       \
        }                                                                       \
                                                                                \
        /* Check cmd response status */                                         \
        Store (DerefOf (Index (Local1, 1)), Local4)                             \
        /* Check if command response is == INJECTION NOT ENABLED */             \
        if (LEqual (Local4, 0x0E)) {                                            \
            /* Error Injection is not enabled - set Ext.Stat. to 1 */           \
            Store (DSM_STS_VEN_SPECIFIC_ERROR, RSTS)                            \
            Store (0x01, REST)                                                  \
            Return (Local0)                                                     \
        }                                                                       \
        Store (CF2D (Local4), RSTS)                                             \
        if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                \
          Return (Local0)                                                       \
        }                                                                       \
    }                                                                           \
                                                                                \
    Return (Local0)                                                             \
  }


//
// Definition of Get Security State
//
// Input:
// Arg0: Function Input
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR19(_DIMM)                                               \
  Method (CR19, 1, Serialized)                                           \
  {                                                                      \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " GetSecurityState") \
    If (LNotEqual (SizeOf (Arg0), 0)) {                                  \
      ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                       \
      If (LNotEqual (SizeOf (Local7), 0)) {                              \
        Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})             \
      }                                                                  \
    }                                                                    \
    Store (Buffer () {0,0,0,0, 0,0,0,0, 0}, Local0)                      \
    CreateDWordField (Local0, 0, RSTS) /* Return status */               \
    Store (CMBC (FIS_CMD_GET_SECURITY_STATE, Buffer () {0,0,0,0}, Zero), Local1) \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    /* Copy security state bits from FIS response to DSM buffer */       \
    Store (DerefOf (Index (DerefOf (Index (Local1, 2)), 0)), Index (Local0, 8)) \
    Store (DerefOf (Index (DerefOf (Index (Local1, 2)), 1)), Index (Local0, 4)) \
    Return (Local0)                                                      \
  }


//
// Definition of Set Passphrase DSM
//
// Input:
// Arg0: Function Input
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR20(_DIMM)                                               \
  Method (CR20, 1, Serialized)                                           \
  {                                                                      \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " SetPassPhrase") \
    Store (Buffer (4) {DSM_STS_SUCCESS, 0, 0, 0}, Local0)                \
    CreateDWordField (Local0, 0, RSTS)                                   \
    If (LEqual (SizeOf (Arg0), 0)) {                                     \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})               \
    }                                                                    \
    ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                         \
    If (LNotEqual (SizeOf (Local7), 64)) {                               \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})               \
    }                                                                    \
    CreateField (Local7, 0, 256, RCPW)                                   \
    CreateField (Local7, 256, 256, RNPW)                                 \
    Store (Buffer (96) {}, Local2)                                       \
    CreateField (Local2, 0, 256, FCPW)                                   \
    CreateField (Local2, 512, 256, FNPW)                                 \
    Store (RCPW, FCPW)                                                   \
    Store (RNPW, FNPW)                                                   \
    Store (CMBC (FIS_CMD_SET_PASSPHRASE, Local2, Zero), Local1)          \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    Return (Local0)                                                      \
  }


//
// Definition of Disable Passphrase DSM
//
// Input:
// Arg0: Function Input
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR21(_DIMM)                                               \
  Method (CR21, 1, Serialized)                                           \
  {                                                                      \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " DisablePassPhrase") \
    Store (Buffer (4) {DSM_STS_SUCCESS, 0, 0, 0}, Local0)                \
    CreateDWordField (Local0, 0, RSTS)                                   \
    If (LEqual (SizeOf (Arg0), 0)) {                                     \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})               \
    }                                                                    \
    ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                         \
    If (LNotEqual (SizeOf (Local7), 32)) {                               \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})               \
    }                                                                    \
    Store (CMBC(FIS_CMD_DISABLE_PASSPHRASE, Local7, Zero), Local1)       \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    Return (Local0)                                                      \
  }


//
// Definition of Unlock Unit DSM
//
// Input:
// Arg0: Function Input
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR22(_DIMM)                                               \
  Method (CR22, 1, Serialized)                                           \
  {                                                                      \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " UnlockUnit") \
    Store (Buffer (4) {DSM_STS_SUCCESS, 0, 0, 0}, Local0)                \
    CreateDWordField (Local0, 0, RSTS)                                   \
    If (LEqual (SizeOf (Arg0), 0)) {                                     \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})               \
    }                                                                    \
    ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                         \
    If (LNotEqual (SizeOf (Local7), 32)) {                               \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})               \
    }                                                                    \
    Store (CMBC(FIS_CMD_UNLOCK_UNIT, Local7, Zero), Local1)              \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    Return (Local0)                                                      \
  }


//
// Definition of Freeze Lock DSM
//
// Input:
// Arg0: Function Input
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR23(_DIMM)                                               \
  Method (CR23, 1, Serialized)                                           \
  {                                                                      \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " FreezeLock") \
    Store (Buffer (4) {DSM_STS_SUCCESS, 0, 0, 0}, Local0)                \
    CreateDWordField (Local0, 0, RSTS)                                   \
    If (LNotEqual (SizeOf (Arg0), 0)) {                                  \
      ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                       \
      If (LNotEqual (SizeOf (Local7), 0)) {                              \
        Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})             \
      }                                                                  \
    }                                                                    \
    Store (CMBC (FIS_CMD_FREEZE_LOCK, Buffer () {0,0,0,0}, Zero), Local1) \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    Return (Local0)                                                      \
  }


//
// Definition of Secure Erase NVDIMM w/ User Passphrase DSM
//
// Input:
// Arg0: Package with Buffer with function parameters
//
// Output: Buffer with function output per NVDIMM DSM spec
//
#define DEFINE_CR24(_DIMM)                                               \
  Method (CR24, 1, Serialized)                                           \
  {                                                                      \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " CR24: SecureEraseNvdimmUser") \
    Store (Buffer (4) {DSM_STS_SUCCESS, 0, 0, 0}, Local0)                \
    CreateDWordField (Local0, 0, RSTS)                                   \
    If (LEqual (SizeOf (Arg0), 0)) {                                     \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " CR24: empty pkg") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})               \
    }                                                                    \
    ToBuffer (DeRefOf (Index (Arg0, 0)), Local1)                         \
    If (LNotEqual (SizeOf (Local1), 32)) {                               \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " CR24: passphrase len != 32") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})               \
    }                                                                    \
    /* Create buffer with parameters for FIS request: 32 bytes for password and 1 byte for type */ \
    Store (Buffer () {0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0}, Local7) \
    CreateField (Local7, 0, 256, PASS)                                   \
    Store (Local1, PASS)                                                 \
    Store (CMBC (FIS_CMD_SECURE_ERASE_UNIT, Local7, Zero), Local1)       \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    Return (Local0)                                                      \
  }


//
// Definition of Overwrite NVDIMM DSM
//
// Input:
// Arg0: Function Input
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR25(_DIMM, Skt, Ch)                                      \
  Method (CR25, 1, Serialized)                                           \
  {                                                                      \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " OverwriteNvdimm") \
    Store (Buffer (4) {DSM_STS_SUCCESS, 0, 0, 0}, Local0)                \
    CreateDWordField (Local0, 0, RSTS)                                   \
    If (LEqual (SizeOf (Arg0), 0)) {                                     \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})               \
    }                                                                    \
    ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                         \
    If (LNotEqual (SizeOf (Local7), 32)) {                               \
      Store (DSM_STS_INVALID_PARAMS, RSTS)                               \
      Return (Local0)                                                    \
    }                                                                    \
    /* If overwrite not allowed because NVDIMM is in 2LM region */       \
    if (LEqual (OS##Skt##Ch, FIS_STS_INCOMPATIBLE_DIMM)) {               \
      DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " OverwriteNvdimm: not allowed") \
      Store (DSM_STS_EXT_OVERWRITE_NOTALLOWED, RSTS)                     \
      Return (Local0)                                                    \
    }                                                                    \
    /* If overwrite is in progress */                                    \
    if (LEqual (OS##Skt##Ch, FIS_STS_DEVICE_BUSY)) {                     \
      DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " OverwriteNvdimm: aleady started") \
      Store (DSM_STS_RETRY_SUGGESTED, RSTS)                              \
      Return (Local0)                                                    \
    }                                                                    \
    Store (OS##Skt##Ch, Local2) /* save value of overwrite status */     \
    Store (FIS_STS_DEVICE_BUSY, OS##Skt##Ch)                             \
    Store (CMBC (FIS_CMD_OVERWRITE_DIMM, Local7, Zero), Local1)          \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Store (Local2, OS##Skt##Ch) /* restore overwrite status */         \
      Return (Local0)                                                    \
    }                                                                    \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Store (Local2, OS##Skt##Ch) /* restore overwrite status */         \
      Return (Local0)                                                    \
    }                                                                    \
    Return (Local0)                                                      \
  }


//
// Definition of Query Overwrite NVDIMM Status DSM
//
// Input:
// Arg0: Function Input
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR26(_DIMM, Skt, Ch)                                      \
  Method (CR26, 1, Serialized)                                           \
  {                                                                      \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " QueryOverwriteNvdimmStatus") \
    Store (Buffer (4) {DSM_STS_SUCCESS, 0, 0, 0}, Local0)                \
    CreateDWordField (Local0, 0, RSTS)                                   \
    If (LNotEqual (SizeOf (Arg0), 0)) {                                  \
      ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                       \
      If (LNotEqual (SizeOf (Local7), 0)) {                              \
        Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})             \
      }                                                                  \
    }                                                                    \
    If (LEqual (OS##Skt##Ch, FIS_STS_DEVICE_BUSY)) {                     \
      CRFF (_ADR) /* query for status in SMI */                          \
    }                                                                    \
    If (LOr (LEqual (OS##Skt##Ch, FIS_STS_INCOMPATIBLE_DIMM),            \
             LEqual (OS##Skt##Ch, FIS_STS_DATA_NOT_SET))) {              \
      Store (DSM_STS_EXT_OVERWRITE_OUTOFSEQUENCE, RSTS)                  \
    } ElseIf (LEqual (OS##Skt##Ch, FIS_STS_DEVICE_BUSY)) {               \
      Store (DSM_STS_EXT_OVERWRITE_INPROGRESS, RSTS)                     \
    } Else {                                                             \
      Store (CF2D (OS##Skt##Ch), RSTS)                                   \
    }                                                                    \
    Return (Local0)                                                      \
  }


//
// Definition of Set Master Passphrase DSM
//
// Input:
// Arg0: Function Input
//
// Output: per NVDIMM DSM spec
//
#define DEFINE_CR27(_DIMM)                                               \
  Method (CR27, 1, Serialized)                                           \
  {                                                                      \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " CR27: SetMasterPassphrase") \
    Store (Buffer (4) {DSM_STS_SUCCESS, 0, 0, 0}, Local0)                \
    CreateDWordField (Local0, 0, RSTS)                                   \
    If (LEqual (SizeOf (Arg0), 0)) {                                     \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " CR27: empty pkg") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})               \
    }                                                                    \
    ToBuffer (DeRefOf (Index (Arg0, 0)), Local7)                         \
    If (LNotEqual (SizeOf (Local7), 64)) {                               \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " CR27: passphrases length != 64") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})               \
    }                                                                    \
    CreateField (Local7, 0, 256, RCPW)                                   \
    CreateField (Local7, 256, 256, RNPW)                                 \
    Store (Buffer (96) {}, Local2)                                       \
    CreateField (Local2, 0, 256, FCPW)                                   \
    CreateField (Local2, 512, 256, FNPW)                                 \
    Store (RCPW, FCPW)                                                   \
    Store (RNPW, FNPW)                                                   \
    Store (CMBC (FIS_CMD_SET_MASTERPASSPHRASE, Local2, Zero), Local1)    \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    Return (Local0)                                                      \
  }


//
// Definition of Secure Erase NVDIMM w/ Masterpassphrase DSM
//
// Input:
// Arg0: Package with Buffer with function parameters
//
// Output: Buffer with function output per NVDIMM DSM spec
//
#define DEFINE_CR28(_DIMM)                                               \
  Method (CR28, 1, Serialized)                                           \
  {                                                                      \
    DEBUG2 (Local6, DEBUG_INFO, "LEAF", STRINGIFY(_DIMM), " CR28: SecureEraseNvdimmMaster") \
    Store (Buffer (4) {DSM_STS_SUCCESS, 0, 0, 0}, Local0)                \
    CreateDWordField (Local0, 0, RSTS)                                   \
    If (LEqual (SizeOf (Arg0), 0)) {                                     \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " CR28: empty pkg") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})               \
    }                                                                    \
    ToBuffer (DeRefOf (Index (Arg0, 0)), Local1)                         \
    If (LNotEqual (SizeOf (Local1), 32)) {                               \
      DEBUG2 (Local6, DEBUG_WARN, "LEAF", STRINGIFY(_DIMM), " CR28: passphrase len != 32") \
      Return (Buffer () {DSM_STS_INVALID_PARAMS, 0, 0, 0})               \
    }                                                                    \
    /* Create buffer with parameters for FIS request: 32 bytes for password and 1 byte for type */ \
    Store (Buffer () {0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 1}, Local7) \
    CreateField (Local7, 0, 256, PASS)                                   \
    Store (Local1, PASS)                                                 \
    Store (CMBC (FIS_CMD_SECURE_ERASE_UNIT, Local7, Zero), Local1)       \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                     \
    If (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                             \
      Return (Local0)                                                    \
    }                                                                    \
    Return (Local0)                                                      \
  }


//
// Retrive Platform Config Data partition size
//
// Input: - (no input)
//
// Output: status [2B] + size in bytes
//
#define DEFINE_PCDS()                                                           \
  Method (PCDS, 0, Serialized)                                                  \
  {                                                                             \
    Store (Buffer (6) {}, Local0)                                               \
    /* Output: Offset 0 [2B]: Status */                                         \
    CreateWordField (Local0, 0, RSTS)                                           \
    /* Output: Offset 4 [4B]: Size of Namespace Label Area */                   \
    CreateDWordField (Local0, 2, RSIZ)                                          \
                                                                                \
    /* Sending (Get) Platform Config Data command to dimm - result in Local1 */ \
    /* Preparing cmd input data in Local2 */                                    \
    Store (Buffer (5) {}, Local2)                                               \
    /* Cmd input Offset 0 [1B]: Partition ID - set to Namespace LSA */          \
    CreateByteField (Local2, 0, PPID)                                           \
    Store (0x02, PPID)                                                          \
    /* Cmd input Offset 1 [1B]: Command Options */                              \
    /* - bit0: Payload Type - set to SMALL_PAYLOAD */                           \
    CreateBitField (Local2, 8, POPT)                                            \
    Store (1, POPT)                                                             \
    /* - bit1: Retrieve Option - set to 1=part. size. */                        \
    CreateBitField (Local2, 9, PORO)                                            \
    Store (1, PORO)                                                             \
                                                                                \
    Store (CMBC (FIS_CMD_GET_PLATFORM_CONFIG, Local2, Zero), Local1)            \
                                                                                \
    /* Check cmd sending status */                                              \
    Store (CF2D (DerefOf (Index (Local1, 0))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Check cmd response status */                                             \
    Store (CF2D (DerefOf (Index (Local1, 1))), RSTS)                            \
    if (LNotEqual (RSTS, DSM_STS_SUCCESS)) {                                    \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Parse cmd response payload */                                            \
    /* Cmd output Offset 0 [4B]: Partition Size */                              \
    CreateDWordField (DerefOf (Index (Local1, 2)), 0, CPSZ)                     \
    Store (CPSZ, RSIZ)                                                          \
                                                                                \
    Return (Local0)                                                             \
  }

//
// Read 128B-chunk of Platform Config Data from given offset
//
// Input:
//   Arg0 - offset <size 4B> (must be aligned to 128B!)
//
// Output: status [2B] + retrived data
//
#define DEFINE_PCDR()                                                           \
  Method (PCDR, 1, Serialized)                                                  \
  {                                                                             \
    /* Parse input data */                                                      \
                                                                                \
    /* Arg0 is an integer (max 4B) offset - store it in IOFF */                 \
    Name (IOFF, 0)                                                              \
    Store (ToInteger (Arg0), IOFF)                                              \
                                                                                \
    /* Prepare output buffer */                                                 \
                                                                                \
    /* Sending (Get) Platform Config Data command to dimm - result in Local1 */ \
    /* Preparing cmd input data in Local2 */                                    \
    Store (Buffer (6) {}, Local2)                                               \
    /* Cmd input: offset 0 [1B]: Partition ID - set to 2=Namespace LSA */       \
    CreateByteField (Local2, 0, QPID)                                           \
    Store (0x02, QPID)                                                          \
    /* Cmd input: offset 1 [1B]: Command Options */                             \
    /* - bit0: Payload Type - set to SMALL_PAYLOAD */                           \
    CreateBitField (Local2, 8, QOPT)                                            \
    Store (1, QOPT)                                                             \
    /* - bit1: Retrieve Option - set to 0=part. data */                         \
    CreateBitField (Local2, 9, QORO)                                            \
    Store (0, QORO)                                                             \
    /* Cmd input: offset 2 [4B]: Offset - set to requested val. */              \
    CreateDWordField (Local2, 2, QOFF)                                          \
    Store (IOFF, QOFF)                                                          \
                                                                                \
    Store (CMBC (FIS_CMD_GET_PLATFORM_CONFIG, Local2, Zero), Local1)            \
                                                                                \
    /* Check cmd sending status */                                              \
    Store (CF2D (DerefOf (Index (Local1, 0))), Local3)                            \
    if (LNotEqual (Local3, DSM_STS_SUCCESS)) {                                    \
      Store (Package () {0}, Local0) \
      Store (Local3, Index(Local0, 0)) \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Check cmd response status */                                             \
    Store (CF2D (DerefOf (Index (Local1, 1))), Local3)                            \
    if (LNotEqual (Local3, DSM_STS_SUCCESS)) {                                    \
      Store (Package () {0}, Local0) \
      Store (Local3, Index(Local0, 0)) \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Parse cmd response payload */                                            \
    /* Cmd output - 128B is copied to out. buf. */                              \
    Store (Package () {0, Buffer (128) {}}, Local0) \
                                                                                \
    /* Copy data to output buffer */                                            \
    Store (DerefOf(Index(Local1, 2)), Index(Local0,1))                                                          \
                                                                                \
    Return (Local0)                                                             \
  }

//
// Write 64B-chunk of Platform Config Data partition
//
// Input:
//   Arg 0 - offset [4B] (must be aligned to 64B!)
//   Arg 1 - data to write [64B]
//
// Output: status of operation [2B]
//
#define DEFINE_PCDW()                                                           \
  Method (PCDW, 2, Serialized)                                                  \
  {                                                                             \
    /* Parse input data */                                                      \
    /* prep. buffer to store input data */                                      \
    Name (IOFF, 0)                                                              \
    Name (IDTA, Buffer (NAMESPACE_DATA_WRITE_CHUNK_SIZE) {} )                   \
                                                                                \
    /* Arg0 is an integer (max 4B) offset - store it in IOFF */                 \
    Store (ToInteger (Arg0) , IOFF)                                             \
                                                                                \
    /* Arg1 - data to write */                                                  \
    Store (Arg1, IDTA)                                                          \
                                                                                \
    /* Sending (Set) Platform Config Data command to dimm - result in Local1 */ \
    /* Preparing cmd input data in Local2 */                                    \
    Store (Buffer (128) {}, Local2)                                             \
    /* Cmd input: offset 0 [1B]: Partition ID - set to 2=Namespace LSA */       \
    CreateByteField (Local2, 0, QPID)                                           \
    Store (0x02, QPID)                                                          \
    /* Cmd input: offset 1 [1B]: Command Options */                             \
    /* - bit0: Payload Type - set to SMALL_PAYLOAD */                           \
    CreateBitField (Local2, 8, QOPT)                                            \
    Store (1, QOPT)                                                             \
    /* - bit1: Retrieve Option - set to 0=part. data */                         \
    CreateBitField (Local2, 9, QORO)                                            \
    Store (0, QORO)                                                             \
    /* Cmd input: offset 2 [4B]: Offset - set to requested val. */              \
    CreateDWordField (Local2, 2, QOFF)                                          \
    Store (IOFF, QOFF)                                                          \
    /* Cmd input: offset 64 [64B]: Data */                                      \
                                                                                \
    CreateField (Local2, 512, 512, QDTA)                                        \
    Store (IDTA, QDTA)                                                          \
                                                                                \
    Store (CMBC (FIS_CMD_SET_PLATFORM_CONFIG, Local2, Zero), Local1)            \
                                                                                \
    /* Check cmd sending status */                                              \
    Store (CF2D (DerefOf (Index (Local1, 0))), Local0)                          \
    if (LNotEqual (Local0, DSM_STS_SUCCESS)) {                                  \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    /* Check cmd response status */                                             \
    Store (CF2D (DerefOf (Index (Local1, 1))), Local0)                          \
    if (LNotEqual (Local0, DSM_STS_SUCCESS)) {                                  \
      Return (Local0)                                                           \
    }                                                                           \
                                                                                \
    Return (Local0)                                                             \
  }

  //
  // CrystalRidge (is) ARS Conflicting Command
  //
  // Checks if command (specified by opcode) conflicts with running ARS.
  // Does not cover Long Ops (they are handled separately in SMM).
  //
  // Input:
  //   Arg0: Opcode
  //
  // Output:
  //   0: command specified by Arg0 can be run while ARS is running
  //   1: command specified by Arg0 cannot be run while ARS is running
  //
  Method (CACC, 1)
  {
    Switch (ToInteger (Arg0)) {
      Case (Package () {FIS_CMD_SECURE_ERASE_UNIT, FIS_CMD_INJECT_POISON}) {
        Return (1)
      }
    }
    Return (0)
  }

// Definition: Crystal Ridge Mailbox Command (CMBC)
//
// Performs mailbox command.
//
// Input:
//   Arg0: Opcode (major occupies low-order byte, minor occupies high-order byte)
//   Arg1: Buffer to write to input payload register
//   Arg2: Timeout (set to zero to use default FIS timeout)
//
// Ouptut: Package:
// Index0: mailbox execution status
//   FIS_STS_SUCCESS:      execution complete
//   FIS_STS_DEVICE_BUSY:  doorbell not clear
//   FIS_STS_TIMEOUT:      timeout waiting for doorbell to clear
//   FIS_STS_INTERNAL_ERR: doorbell clear but completion not set
// Index1:
//   Index0 != FIS_STS_SUCCESS: not present
//   Index0 == FIS_STS_SUCCESS: mailbox status code (from mailbox status CSR)
// Index2:
//   Index1 not present:       not present
//   Index1 != FIS_STS_SUCCESS: not present
//   Index1 == FIS_STS_SUCCESS: output payload (128 bytes)
//
//#define FIS_DUMP_SIZE 64
#if FIS_DUMP_SIZE
#define DEBUG_INPUT_DUMP DEBUG4
#define DEBUG_OUTPUT_DUMP DEBUG4
#define DEBUG_OUTPUT(...)
#else
#define DEBUG_INPUT_DUMP(...)
#define DEBUG_OUTPUT_DUMP(...)
#define DEBUG_OUTPUT DEBUG7
#endif
#define DEFINE_CMBC(_DIMM, _SKT, _CH) \
  Method (CMBC, 3, Serialized) \
  { \
    Store (Timer, Local3) \
    DEBUG_INPUT_DUMP (Local6, DEBUG_INFO, "FIS ", STRINGIFY(_DIMM), ToHexString(Arg0), " input: ", ToHexString(Mid(Arg1,0,FIS_DUMP_SIZE))) \
    ACQUIRE (NMTX, 0xFFFF) \
    if (LAnd (LAnd (LNotEqual (BARS, Zero), LNotEqual (CACC (Arg0), Zero)), LEqual (LO##_SKT##_CH, FIS_CMD_SET_ADDRESS_RANGE_SCRUB))) { \
      DEBUG3 (Local6, DEBUG_INFO, "FIS ", STRINGIFY(_DIMM), ToHexString(Arg0), ": recursing into CMBC") \
      CMBC (FIS_CMD_SET_ADDRESS_RANGE_SCRUB, Buffer (20) {0x00}, Zero) \
      Sleep (1) \
      Store (1, NTFY) \
    } \
    Name (TCMD, Buffer (8) {}) \
    Name (TSTA, Buffer (8) {}) \
    Store (XCMD, TCMD) \
    CreateField (TCMD, 32, 16, TOPC) \
    CreateField (TCMD, 48, 1,  TDRB) \
    CreateField (TCMD, 63, 1,  TSEQ) \
    if (LEqual (ToInteger (TDRB), 1)) { \
      DEBUG3 (Local6, DEBUG_ERROR, "FIS ", STRINGIFY(_DIMM), ToHexString(Arg0), ": Previous command did not complete") \
      RELEASE (NMTX) \
      if (LNotEqual (NTFY, Zero)) { \
        NVRN (1) \
        Store (Zero, NTFY) \
      } \
      Return (Package () {FIS_STS_DEVICE_BUSY}) \
    } \
    Store (SizeOf (Arg1), Local4) \
    ShiftRight(Add (Local4, 7), 3, Local4) \
    Store (Zero, Local5) \
    while (1) { \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 01, Local4, Local7) \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 02, Local4, Local7) \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 03, Local4, Local7) \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 04, Local4, Local7) \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 05, Local4, Local7) \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 06, Local4, Local7) \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 07, Local4, Local7) \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 08, Local4, Local7) \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 09, Local4, Local7) \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 0A, Local4, Local7) \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 0B, Local4, Local7) \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 0C, Local4, Local7) \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 0D, Local4, Local7) \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 0E, Local4, Local7) \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 0F, Local4, Local7) \
      WRITE_ONE_INPUT_PAYLOAD_REG(Arg1, Local5, 10, Local4, Local7) \
      Break \
    } \
    Store (Timer, Local0) \
    Store (Arg0, TOPC) \
    If (LEqual (ToInteger(TSEQ), 1)) { \
      Store (0, TSEQ) \
    } else { \
      Store (1, TSEQ) \
    } \
    Store (1, TDRB) \
    /* get timeout if not specified */ \
    if (LEqual (ToInteger (Arg2), Zero)) { \
      Store (CGTM (Arg0, XSTA), Local1) \
    } else { \
      /* convert timeout to from ms to 100ns resolution */ \
      Store (Multiply (ToInteger (Arg2), 10000), Local1) \
    } \
    /* command start */ \
    Store (ToInteger(TCMD), XCMD) \
    Store (0xFFFFFFFFFFFFFFFF, FL01) \
    Store (0xFFFFFFFFFFFFFFFF, FL02) \
    Store (0xFFFFFFFFFFFFFFFF, FL03) \
    Store (0xFFFFFFFFFFFFFFFF, FL04) \
    Store (0xFFFFFFFFFFFFFFFF, FL05) \
    Store (0xFFFFFFFFFFFFFFFF, FL06) \
    Store (0xFFFFFFFFFFFFFFFF, FL07) \
    Store (0xFFFFFFFFFFFFFFFF, FL08) \
    Store (0xFFFFFFFFFFFFFFFF, FL09) \
    Store (0xFFFFFFFFFFFFFFFF, FL0A) \
    Store (0xFFFFFFFFFFFFFFFF, FL0B) \
    Store (0xFFFFFFFFFFFFFFFF, FL0C) \
    Store (0xFFFFFFFFFFFFFFFF, FL0D) \
    Store (0xFFFFFFFFFFFFFFFF, FL0E) \
    Store (0xFFFFFFFFFFFFFFFF, FL0F) \
    Store (0xFFFFFFFFFFFFFFFF, FL10) \
    Store (0xFFFFFFFFFFFFFFFF, FL11) \
    Store (0xFFFFFFFFFFFFFFFF, FL12) \
    Store (0xFFFFFFFFFFFFFFFF, FL13) \
    Store (0xFFFFFFFFFFFFFFFF, FL14) \
    Store (0xFFFFFFFFFFFFFFFF, FL15) \
    Store (0xFFFFFFFFFFFFFFFF, FL16) \
    Store (0xFFFFFFFFFFFFFFFF, FL17) \
    Store (0xFFFFFFFFFFFFFFFF, FL18) \
    Store (0xFFFFFFFFFFFFFFFF, FL19) \
    Store (0xFFFFFFFFFFFFFFFF, FL1A) \
    Store (0xFFFFFFFFFFFFFFFF, FL1B) \
    Store (0xFFFFFFFFFFFFFFFF, FL1C) \
    Store (0xFFFFFFFFFFFFFFFF, FL1D) \
    Store (0xFFFFFFFFFFFFFFFF, FL1E) \
    Store (0xFFFFFFFFFFFFFFFF, FL1F) \
    Store (0xFFFFFFFFFFFFFFFF, FL20) \
    Store (FL20, Local5) \
    Store (Timer, Local5) \
    Store(Zero, Local4) \
    Store(Zero, Local7) \
    while (1) { \
      Store (XCMD, TCMD) \
      if (LEqual (ToInteger (TDRB), 0)) { \
        Break \
      } \
      Store (Local4, Local7) \
      Subtract (Timer, Local5, Local4) \
      if (LGreater (Local4, Local1)) { \
        Store (XCMD, TCMD) \
        if (LEqual (ToInteger (TDRB), 0)) { \
          Break \
        } \
        DEBUG7 (Local6, DEBUG_ERROR, "FIS ", STRINGIFY(_DIMM), ToHexString(Arg0), ": Doorbell still set, waited ", ToHexString(Local4), " [x100ns] (prev", ToHexString(Local7), ")") \
        RELEASE (NMTX) \
        if (LNotEqual (NTFY, Zero)) { \
          NVRN (1) \
          Store (Zero, NTFY) \
        } \
        Return (Package () {FIS_STS_TIMEOUT}) \
      } \
    } \
    if (LGreater(Local4, Local1)) { \
        DEBUG7 (Local6, DEBUG_WARN, "FIS ", STRINGIFY(_DIMM), ToHexString(Arg0), ": Long iteration, scheduling issues? ", ToHexString(Local4), " [x100ns] (prev ", ToHexString (Local7), ")") \
    } \
    Store (XSTA, TSTA) \
    CreateField (TSTA, 0, 1, TCMP) \
    CreateField (TSTA, 8, 8, TMBS) \
    if (LEqual (ToInteger (TCMP), 0)) { \
      DEBUG3 (Local6, DEBUG_ERROR, "FIS ", STRINGIFY(_DIMM), ToHexString(Arg0), ": Completion bit not set") \
      RELEASE (NMTX) \
      if (LNotEqual (NTFY, Zero)) { \
        NVRN (1) \
        Store (Zero, NTFY) \
      } \
      Return (Package () {FIS_STS_INTERNAL_ERR}) \
    } \
    /* command completed */ \
    if (LNotEqual (ToInteger (TMBS), 0)) { \
      Store (Package () {FIS_STS_SUCCESS, 0x00}, Local7) \
      Store (ToInteger (TMBS), Index (Local7, 1)) \
      DEBUG4 (Local6, DEBUG_ERROR, "FIS ", STRINGIFY(_DIMM), ToHexString(Arg0), ": mailbox failure: ", ToHexString(ToInteger(TMBS))) \
      RELEASE (NMTX) \
      if (LNotEqual (NTFY, Zero)) { \
        NVRN (1) \
        Store (Zero, NTFY) \
      } \
      Return (Local7) \
    } \
    Store (Timer, Local2) \
    Store (Package () {FIS_STS_SUCCESS, FIS_STS_SUCCESS, Buffer (128) {}}, Local7) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x00, BO01) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x08, BO02) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x10, BO03) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x18, BO04) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x20, BO05) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x28, BO06) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x30, BO07) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x38, BO08) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x40, BO09) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x48, BO0A) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x50, BO0B) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x58, BO0C) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x60, BO0D) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x68, BO0E) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x70, BO0F) \
    CreateQWordField (DerefOf (Index (Local7, 2)), 0x78, BO10) \
    Store (16, Local4) \
    while (1) { \
      READ_ONE_OUTPUT_PAYLOAD_REG(01, Local4) \
      READ_ONE_OUTPUT_PAYLOAD_REG(02, Local4) \
      READ_ONE_OUTPUT_PAYLOAD_REG(03, Local4) \
      READ_ONE_OUTPUT_PAYLOAD_REG(04, Local4) \
      READ_ONE_OUTPUT_PAYLOAD_REG(05, Local4) \
      READ_ONE_OUTPUT_PAYLOAD_REG(06, Local4) \
      READ_ONE_OUTPUT_PAYLOAD_REG(07, Local4) \
      READ_ONE_OUTPUT_PAYLOAD_REG(08, Local4) \
      READ_ONE_OUTPUT_PAYLOAD_REG(09, Local4) \
      READ_ONE_OUTPUT_PAYLOAD_REG(0A, Local4) \
      READ_ONE_OUTPUT_PAYLOAD_REG(0B, Local4) \
      READ_ONE_OUTPUT_PAYLOAD_REG(0C, Local4) \
      READ_ONE_OUTPUT_PAYLOAD_REG(0D, Local4) \
      READ_ONE_OUTPUT_PAYLOAD_REG(0E, Local4) \
      READ_ONE_OUTPUT_PAYLOAD_REG(0F, Local4) \
      READ_ONE_OUTPUT_PAYLOAD_REG(10, Local4) \
      Break \
    } \
    DEBUG_OUTPUT_DUMP (Local6, DEBUG_INFO, "FIS ", STRINGIFY(_DIMM), ToHexString(Arg0), " completed, output: ", ToHexString(Mid(DerefOf(Index(Local7,2)),0,FIS_DUMP_SIZE))) \
    Store (Timer, Local1) \
    Subtract (Local1, Local2, Local1) \
    Subtract (Local2, Local0, Local2) \
    Subtract (Local0, Local3, Local0) \
    Store (SizeOf(Arg1), Local3) \
    DEBUG_OUTPUT (Local6, DEBUG_INFO, "FIS ", STRINGIFY(_DIMM), ToHexString(Arg0), " len/input written/executed/output written at [x100ns] ", ToHexString(Local3), ToHexString(Local0), ToHexString (Local2), ToHexString (Local1)) \
    RELEASE (NMTX) \
    if (LNotEqual (NTFY, Zero)) { \
      NVRN (1) \
      Store (Zero, NTFY) \
    } \
    Return (Local7) \
  }


  //
  // Root DSM implementation
  // Input:
  //   Arg0: GUID
  //   Arg1: Revision
  //   Arg2: Function Index
  //   Arg3: Function Input
  //
  Name (ETSE, 0xFFFFFFFFFFFFFFFF) // Estimated time scrub ends
  Method (CRRD, 4, Serialized)
  {
    ToInteger (Arg1, Local1)
    ToInteger (Arg2, Local2)

    If (LEqual (Local2, 0)) {
      If (LAnd (LEqual (Arg0, ToUUID (DSM_ROOT_UUID)), LEqual (Local1, 1))) {
        Return (Buffer() {0xBF, 0x03}) // Functions 0..5,7..9 are supported
      } Else {
        Return (Buffer() {Zero})    // nothing supported for any other UUID/revision
      }
    }

    If (LEqual (Arg0, ToUUID (DSM_ROOT_UUID))) {  // Make sure correct UUID
      If (LNotEqual (Local1, 1)) {                // Make sure revision is 1
        Return (Buffer () {Zero})
      }

      If (SizeOf (Arg3)) {
        ToBuffer (DeRefOf (Index (Arg3, 0)), Local3)
        Store (SizeOf (Local3), Local5)
        If (LGreater (Local5, DSM_INPB_SIZE)) {
          Return (Buffer () {ROOT_STATUS_INVALID_INPUT_PARAMETERS, 0, 0, 0})
        }
      } Else {
        Store (Zero, Local5)
      }

      If (LEqual (Local2, DSM_ROOT_QUERY_ARS_STATUS)) {
        If (LNotEqual (Local5, Zero)) {
          Return (Buffer () {ROOT_STATUS_INVALID_INPUT_PARAMETERS, 0, 0, 0})
        }
        DEBUG1 (Local6, DEBUG_INFO, "ROOT", "Query ARS Status")
        if (LNotEqual (SAWO, Zero)) {
          ACQUIRE (NMTX, 0xFFFF)
          Store (DSM_ROOT_STOP_ARS_AND_UPDATE_STATUS, FUNI)
          Store (DSM_ROOT_DEVICE_ACPI_HANDLE, NFHD)
          Store (0, INPL)
          CSMI (DCPMM_DSM_SWSMI)
          RELEASE (NMTX)
        } elseif (LGreaterEqual (Timer, ETSE)) {
          CRFF (DSM_ROOT_DEVICE_ACPI_HANDLE)
        }
        Store (ASPB, Local7)
        Store (Local7, ASBL)
        if (LEqual (Local7, Zero)) {
          Store (ASL0, Local0)
          Store (AST0, Local1)
        } else {
          Store (ASL1, Local0)
          Store (AST1, Local1)
        }
        Name (RETA, Buffer (Add (Local0, 4)) {} )
        CreateDwordField (RETA, 0x00, STAA)
        Store (Local1, STAA)
        CreateField (RETA, 0x20, Multiply (Local0, 8), DATA)
        if (LEqual (Local7, Zero)) {
          Mid (ASB0, 0, Local0, DATA)
        } else {
          Mid (ASB1, 0, Local0, DATA)
        }
        Store (0xFF, ASBL)

        If (LNotEqual (STAA, 0x00010000)) { // If ARS not in progress
          Store (0xFFFFFFFFFFFFFFFF, ETSE)  // Disable polling for status
        }
        Store (0, SAWO)
        Return (RETA)
      }
      if (LAnd (LGreaterEqual (Local2, DSM_ROOT_ARS_ERROR_INJECT),
                LLessEqual (Local2, DSM_ROOT_ARS_ERROR_INJECT_STATUS_QUERY))) {
        if (LEqual (INJE, Zero)) {
          Return (Buffer () {ROOT_STATUS_FUNCTION_NOT_SUPPORTED, 0, 0, 0})
        }
      }

      // Store Function Index and NFIT Device Handle
      ACQUIRE (NMTX, 0xFFFF)
      Store (Local2, FUNI)
      Store (DSM_ROOT_DEVICE_ACPI_HANDLE, NFHD)  // Specify call is being made from NVDR

      If (Local5) {
        Store (Local3, INPB)
      }
      Store (Local5, INPL)

      CSMI (DCPMM_DSM_SWSMI)

      // Create Return Buffer
      Name (RETB, Buffer (Add (OUTL, 4)) {} )

      // Update Status
      CreateDwordField (RETB, 0x00, STAT) // Status
      Store (NFST, STAT)

      // Copy buffer
      If (LNotEqual (OUTL, 0)) {
        CreateField (RETB, 0x20, Multiply (OUTL, 8), DATB)
        Mid (OUTB, 0, OUTL, DATB)
      }
      if (LAnd (LEqual (Local2, DSM_ROOT_START_ARS), LEqual (NFST, ACPI_STS_SUCCESS))) {
        CreateDWordField (RETB, 4, ETFS)               // Locate Estimated Time for Scrub
        if (LNotEqual (ETFS, Zero)) {                  // Don't poll for Short ARS
          Add (Timer, Multiply (ETFS, 10000000), ETSE) // Calculate estimated time scrub ends
        }
      }
      RELEASE (NMTX)
      Return (RETB) // Return output buffer
    }
    Return (Buffer() {0x00})
  }

//
// This method invokes internal DSM to check long operation state
// on provided NVDIMM. It is used if ACPI cannot relay in DDRT
// SMI interrupt updating long operation state.
//
// Input:
//   Arg0 - NFIT handle of NVDIMM, or 0xFFFFFFFF for root device
//
Method (CRFF, 1, Serialized)
{
  If (And (ICTL, ICTL_NODDRTSMI)) {
    ACQUIRE (NMTX, 0xFFFF)
    Store (DSM_FN_CHECK_LONGOP_STATE, FUNI)
    Store (ToInteger (Arg0), NFHD)
    Store (0, INPL)
    CSMI (DCPMM_DSM_SWSMI)
    RELEASE (NMTX)
  }
}

//
// Timestamp of last SMI triggered on behalf of a DSM
//
Name (LSMI, 0)

//
// Triggers an SWSMI at rate no higher than 1/sec
// Input:
//   Arg0: SWSMI number
//
Method (CSMI, 1) {
  if (And (ICTL, ICTL_LSX_ASL)) {
    Store (Timer, Local0)
    Subtract (Local0, LSMI, Local1)
    if (LLess (Local1, TFSM)) {
      Subtract (TFSM, Local1, Local1)
      DEBUG2 (Local6, DEBUG_WARN, "SMI ", "Delaying SWSMI [100ns]: ", ToDecimalString (Local1))
      Sleep (Divide (Local1, 10000))
      Store (Timer, LSMI)
    } else {
      Store (Local0, LSMI)
    }
  }
  Store (10000000 ,TFSM)
  Store (Arg0, SMIC)
}
